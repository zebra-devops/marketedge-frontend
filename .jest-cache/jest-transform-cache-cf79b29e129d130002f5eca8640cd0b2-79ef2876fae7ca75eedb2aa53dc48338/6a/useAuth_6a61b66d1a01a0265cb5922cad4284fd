dc04760ccc693b0a9c63874e85dc6e54
"use client";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AuthContext: function() {
        return AuthContext;
    },
    useAuth: function() {
        return useAuth;
    },
    useAuthContext: function() {
        return useAuthContext;
    }
});
const _react = require("react");
const _auth = require("../services/auth");
const _timerutils = require("../utils/timer-utils");
const AuthContext = (0, _react.createContext)(undefined);
const useAuthContext = ()=>{
    const context = (0, _react.useContext)(AuthContext);
    if (!context) {
        throw new Error("useAuthContext must be used within an AuthProvider");
    }
    return context;
};
const useAuth = ()=>{
    const [state, setState] = (0, _react.useState)({
        user: null,
        tenant: null,
        permissions: [],
        isLoading: true,
        isAuthenticated: false,
        isInitialized: false
    });
    (0, _react.useEffect)(()=>{
        initializeAuth();
    }, []);
    // Initialize timer-based features only on client-side after mount
    (0, _react.useEffect)(()=>{
        if (typeof window !== "undefined") {
            // Ensure timer functions are available before initialization
            (0, _timerutils.ensureTimerFunctions)();
            // Initialize auto-refresh and activity tracking
            _auth.authService.initializeAutoRefresh();
            _auth.authService.initializeActivityTracking();
            // Cleanup function to clear intervals when component unmounts
            return ()=>{
                const refreshInterval = window.__authRefreshInterval;
                const timeoutInterval = window.__sessionTimeoutInterval;
                if (refreshInterval) {
                    (0, _timerutils.safeClearInterval)(refreshInterval);
                    delete window.__authRefreshInterval;
                }
                if (timeoutInterval) {
                    (0, _timerutils.safeClearInterval)(timeoutInterval);
                    delete window.__sessionTimeoutInterval;
                }
            };
        }
    }, [
        state.isAuthenticated
    ]) // Re-initialize when auth state changes
    ;
    const initializeAuth = async ()=>{
        try {
            setState((prev)=>({
                    ...prev,
                    isLoading: true
                }));
            // Check if user has valid authentication
            if (_auth.authService.isAuthenticated()) {
                try {
                    // Get current user data from backend
                    const userResponse = await _auth.authService.getCurrentUser();
                    const permissions = _auth.authService.getUserPermissions();
                    setState({
                        user: userResponse.user,
                        tenant: userResponse.tenant,
                        permissions,
                        isLoading: false,
                        isAuthenticated: true,
                        isInitialized: true
                    });
                } catch (error) {
                    console.error("Failed to get current user:", error);
                    // Clear invalid tokens
                    await _auth.authService.logout();
                    setState({
                        user: null,
                        tenant: null,
                        permissions: [],
                        isLoading: false,
                        isAuthenticated: false,
                        isInitialized: true
                    });
                }
            } else {
                setState({
                    user: null,
                    tenant: null,
                    permissions: [],
                    isLoading: false,
                    isAuthenticated: false,
                    isInitialized: true
                });
            }
        } catch (error) {
            console.error("Auth initialization failed:", error);
            setState({
                user: null,
                tenant: null,
                permissions: [],
                isLoading: false,
                isAuthenticated: false,
                isInitialized: true
            });
        }
    };
    const login = async (loginData)=>{
        setState((prev)=>({
                ...prev,
                isLoading: true
            }));
        try {
            const response = await _auth.authService.login(loginData);
            setState({
                user: response.user,
                tenant: response.tenant,
                permissions: response.permissions,
                isLoading: false,
                isAuthenticated: true,
                isInitialized: true
            });
            return response;
        } catch (error) {
            setState((prev)=>({
                    ...prev,
                    isLoading: false,
                    user: null,
                    tenant: null,
                    permissions: [],
                    isAuthenticated: false
                }));
            throw error;
        }
    };
    const logout = async (allDevices = false)=>{
        setState((prev)=>({
                ...prev,
                isLoading: true
            }));
        try {
            await _auth.authService.logout(allDevices);
        } catch (error) {
            console.warn("Logout error:", error);
        } finally{
            setState({
                user: null,
                tenant: null,
                permissions: [],
                isLoading: false,
                isAuthenticated: false,
                isInitialized: true
            });
        }
    };
    const refreshUser = async ()=>{
        try {
            const userResponse = await _auth.authService.getCurrentUser();
            const permissions = _auth.authService.getUserPermissions();
            setState((prev)=>({
                    ...prev,
                    user: userResponse.user,
                    tenant: userResponse.tenant,
                    permissions
                }));
        } catch (error) {
            console.error("Failed to refresh user data:", error);
            throw error;
        }
    };
    const hasPermission = (permission)=>{
        return _auth.authService.hasPermission(permission);
    };
    const hasAnyPermission = (permissions)=>{
        return _auth.authService.hasAnyPermission(permissions);
    };
    const hasRole = (role)=>{
        return _auth.authService.getUserRole() === role;
    };
    const checkSession = async ()=>{
        try {
            return await _auth.authService.checkSession();
        } catch (error) {
            console.error("Session check failed:", error);
            throw error;
        }
    };
    const extendSession = async ()=>{
        try {
            return await _auth.authService.extendSession();
        } catch (error) {
            console.error("Session extension failed:", error);
            throw error;
        }
    };
    const getTenantContext = ()=>{
        return state.tenant;
    };
    const validateTenantAccess = (requiredTenant)=>{
        if (!state.tenant || !state.isAuthenticated) {
            return false;
        }
        return state.tenant.id === requiredTenant;
    };
    return {
        ...state,
        login,
        logout,
        refreshUser,
        hasPermission,
        hasAnyPermission,
        hasRole,
        checkSession,
        extendSession,
        getTenantContext,
        validateTenantAccess
    };
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0L1NpdGVzL01hcmtldEVkZ2UvcGxhdGZvcm0td3JhcHBlci9mcm9udGVuZC9zcmMvaG9va3MvdXNlQXV0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXNlciB9IGZyb20gJ0AvdHlwZXMvYXV0aCdcbmltcG9ydCB7IGF1dGhTZXJ2aWNlIH0gZnJvbSAnQC9zZXJ2aWNlcy9hdXRoJ1xuaW1wb3J0IHsgc2FmZUNsZWFySW50ZXJ2YWwsIGVuc3VyZVRpbWVyRnVuY3Rpb25zIH0gZnJvbSAnQC91dGlscy90aW1lci11dGlscydcblxuaW50ZXJmYWNlIEVuaGFuY2VkVXNlciBleHRlbmRzIFVzZXIge1xuICBjcmVhdGVkX2F0Pzogc3RyaW5nXG4gIHVwZGF0ZWRfYXQ/OiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIFRlbmFudEluZm8ge1xuICBpZDogc3RyaW5nXG4gIG5hbWU6IHN0cmluZ1xuICBpbmR1c3RyeTogc3RyaW5nXG4gIHN1YnNjcmlwdGlvbl9wbGFuOiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIEF1dGhTdGF0ZSB7XG4gIHVzZXI6IEVuaGFuY2VkVXNlciB8IG51bGxcbiAgdGVuYW50OiBUZW5hbnRJbmZvIHwgbnVsbFxuICBwZXJtaXNzaW9uczogc3RyaW5nW11cbiAgaXNMb2FkaW5nOiBib29sZWFuXG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhblxuICBpc0luaXRpYWxpemVkOiBib29sZWFuXG59XG5cbmludGVyZmFjZSBBdXRoQ29udGV4dFR5cGUgZXh0ZW5kcyBBdXRoU3RhdGUge1xuICBsb2dpbjogKGxvZ2luRGF0YTogeyBjb2RlOiBzdHJpbmc7IHJlZGlyZWN0X3VyaTogc3RyaW5nOyBzdGF0ZT86IHN0cmluZyB9KSA9PiBQcm9taXNlPGFueT5cbiAgbG9nb3V0OiAoYWxsRGV2aWNlcz86IGJvb2xlYW4pID0+IFByb21pc2U8dm9pZD5cbiAgcmVmcmVzaFVzZXI6ICgpID0+IFByb21pc2U8dm9pZD5cbiAgaGFzUGVybWlzc2lvbjogKHBlcm1pc3Npb246IHN0cmluZykgPT4gYm9vbGVhblxuICBoYXNBbnlQZXJtaXNzaW9uOiAocGVybWlzc2lvbnM6IHN0cmluZ1tdKSA9PiBib29sZWFuXG4gIGhhc1JvbGU6IChyb2xlOiBzdHJpbmcpID0+IGJvb2xlYW5cbiAgY2hlY2tTZXNzaW9uOiAoKSA9PiBQcm9taXNlPGFueT5cbiAgZXh0ZW5kU2Vzc2lvbjogKCkgPT4gUHJvbWlzZTxhbnk+XG4gIGdldFRlbmFudENvbnRleHQ6ICgpID0+IFRlbmFudEluZm8gfCBudWxsXG4gIHZhbGlkYXRlVGVuYW50QWNjZXNzOiAocmVxdWlyZWRUZW5hbnQ6IHN0cmluZykgPT4gYm9vbGVhblxufVxuXG5jb25zdCBBdXRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8QXV0aENvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpXG5cbmV4cG9ydCBjb25zdCB1c2VBdXRoQ29udGV4dCA9ICgpOiBBdXRoQ29udGV4dFR5cGUgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBdXRoQ29udGV4dClcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VBdXRoQ29udGV4dCBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEF1dGhQcm92aWRlcicpXG4gIH1cbiAgcmV0dXJuIGNvbnRleHRcbn1cblxuZXhwb3J0IGNvbnN0IHVzZUF1dGggPSAoKTogQXV0aENvbnRleHRUeXBlID0+IHtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTxBdXRoU3RhdGU+KHtcbiAgICB1c2VyOiBudWxsLFxuICAgIHRlbmFudDogbnVsbCxcbiAgICBwZXJtaXNzaW9uczogW10sXG4gICAgaXNMb2FkaW5nOiB0cnVlLFxuICAgIGlzQXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgaXNJbml0aWFsaXplZDogZmFsc2VcbiAgfSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGluaXRpYWxpemVBdXRoKClcbiAgfSwgW10pXG5cbiAgLy8gSW5pdGlhbGl6ZSB0aW1lci1iYXNlZCBmZWF0dXJlcyBvbmx5IG9uIGNsaWVudC1zaWRlIGFmdGVyIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBFbnN1cmUgdGltZXIgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgYmVmb3JlIGluaXRpYWxpemF0aW9uXG4gICAgICBlbnN1cmVUaW1lckZ1bmN0aW9ucygpXG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgYXV0by1yZWZyZXNoIGFuZCBhY3Rpdml0eSB0cmFja2luZ1xuICAgICAgYXV0aFNlcnZpY2UuaW5pdGlhbGl6ZUF1dG9SZWZyZXNoKClcbiAgICAgIGF1dGhTZXJ2aWNlLmluaXRpYWxpemVBY3Rpdml0eVRyYWNraW5nKClcblxuICAgICAgLy8gQ2xlYW51cCBmdW5jdGlvbiB0byBjbGVhciBpbnRlcnZhbHMgd2hlbiBjb21wb25lbnQgdW5tb3VudHNcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZnJlc2hJbnRlcnZhbCA9ICh3aW5kb3cgYXMgYW55KS5fX2F1dGhSZWZyZXNoSW50ZXJ2YWxcbiAgICAgICAgY29uc3QgdGltZW91dEludGVydmFsID0gKHdpbmRvdyBhcyBhbnkpLl9fc2Vzc2lvblRpbWVvdXRJbnRlcnZhbFxuICAgICAgICBcbiAgICAgICAgaWYgKHJlZnJlc2hJbnRlcnZhbCkge1xuICAgICAgICAgIHNhZmVDbGVhckludGVydmFsKHJlZnJlc2hJbnRlcnZhbClcbiAgICAgICAgICBkZWxldGUgKHdpbmRvdyBhcyBhbnkpLl9fYXV0aFJlZnJlc2hJbnRlcnZhbFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodGltZW91dEludGVydmFsKSB7XG4gICAgICAgICAgc2FmZUNsZWFySW50ZXJ2YWwodGltZW91dEludGVydmFsKVxuICAgICAgICAgIGRlbGV0ZSAod2luZG93IGFzIGFueSkuX19zZXNzaW9uVGltZW91dEludGVydmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFtzdGF0ZS5pc0F1dGhlbnRpY2F0ZWRdKSAvLyBSZS1pbml0aWFsaXplIHdoZW4gYXV0aCBzdGF0ZSBjaGFuZ2VzXG5cbiAgY29uc3QgaW5pdGlhbGl6ZUF1dGggPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHNldFN0YXRlKHByZXYgPT4gKHsgLi4ucHJldiwgaXNMb2FkaW5nOiB0cnVlIH0pKVxuXG4gICAgICAvLyBDaGVjayBpZiB1c2VyIGhhcyB2YWxpZCBhdXRoZW50aWNhdGlvblxuICAgICAgaWYgKGF1dGhTZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gR2V0IGN1cnJlbnQgdXNlciBkYXRhIGZyb20gYmFja2VuZFxuICAgICAgICAgIGNvbnN0IHVzZXJSZXNwb25zZSA9IGF3YWl0IGF1dGhTZXJ2aWNlLmdldEN1cnJlbnRVc2VyKClcbiAgICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IGF1dGhTZXJ2aWNlLmdldFVzZXJQZXJtaXNzaW9ucygpXG4gICAgICAgICAgXG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlcjogdXNlclJlc3BvbnNlLnVzZXIsXG4gICAgICAgICAgICB0ZW5hbnQ6IHVzZXJSZXNwb25zZS50ZW5hbnQsXG4gICAgICAgICAgICBwZXJtaXNzaW9ucyxcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpc0luaXRpYWxpemVkOiB0cnVlXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGN1cnJlbnQgdXNlcjonLCBlcnJvcilcbiAgICAgICAgICAvLyBDbGVhciBpbnZhbGlkIHRva2Vuc1xuICAgICAgICAgIGF3YWl0IGF1dGhTZXJ2aWNlLmxvZ291dCgpXG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgICAgIHRlbmFudDogbnVsbCxcbiAgICAgICAgICAgIHBlcm1pc3Npb25zOiBbXSxcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNJbml0aWFsaXplZDogdHJ1ZVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICB1c2VyOiBudWxsLFxuICAgICAgICAgIHRlbmFudDogbnVsbCxcbiAgICAgICAgICBwZXJtaXNzaW9uczogW10sXG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGlzSW5pdGlhbGl6ZWQ6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQXV0aCBpbml0aWFsaXphdGlvbiBmYWlsZWQ6JywgZXJyb3IpXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIHVzZXI6IG51bGwsXG4gICAgICAgIHRlbmFudDogbnVsbCxcbiAgICAgICAgcGVybWlzc2lvbnM6IFtdLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgICAgICBpc0luaXRpYWxpemVkOiB0cnVlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGxvZ2luID0gYXN5bmMgKGxvZ2luRGF0YTogeyBjb2RlOiBzdHJpbmc7IHJlZGlyZWN0X3VyaTogc3RyaW5nOyBzdGF0ZT86IHN0cmluZyB9KSA9PiB7XG4gICAgc2V0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBpc0xvYWRpbmc6IHRydWUgfSkpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aFNlcnZpY2UubG9naW4obG9naW5EYXRhKVxuICAgICAgXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIHVzZXI6IHJlc3BvbnNlLnVzZXIsXG4gICAgICAgIHRlbmFudDogcmVzcG9uc2UudGVuYW50LFxuICAgICAgICBwZXJtaXNzaW9uczogcmVzcG9uc2UucGVybWlzc2lvbnMsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgICAgaXNJbml0aWFsaXplZDogdHJ1ZVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgdGVuYW50OiBudWxsLFxuICAgICAgICBwZXJtaXNzaW9uczogW10sXG4gICAgICAgIGlzQXV0aGVudGljYXRlZDogZmFsc2VcbiAgICAgIH0pKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBjb25zdCBsb2dvdXQgPSBhc3luYyAoYWxsRGV2aWNlczogYm9vbGVhbiA9IGZhbHNlKSA9PiB7XG4gICAgc2V0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBpc0xvYWRpbmc6IHRydWUgfSkpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGF1dGhTZXJ2aWNlLmxvZ291dChhbGxEZXZpY2VzKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0xvZ291dCBlcnJvcjonLCBlcnJvcilcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICB1c2VyOiBudWxsLFxuICAgICAgICB0ZW5hbnQ6IG51bGwsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbXSxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgaXNBdXRoZW50aWNhdGVkOiBmYWxzZSxcbiAgICAgICAgaXNJbml0aWFsaXplZDogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBjb25zdCByZWZyZXNoVXNlciA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXNlclJlc3BvbnNlID0gYXdhaXQgYXV0aFNlcnZpY2UuZ2V0Q3VycmVudFVzZXIoKVxuICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBhdXRoU2VydmljZS5nZXRVc2VyUGVybWlzc2lvbnMoKVxuICAgICAgXG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIHVzZXI6IHVzZXJSZXNwb25zZS51c2VyLFxuICAgICAgICB0ZW5hbnQ6IHVzZXJSZXNwb25zZS50ZW5hbnQsXG4gICAgICAgIHBlcm1pc3Npb25zXG4gICAgICB9KSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlZnJlc2ggdXNlciBkYXRhOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBjb25zdCBoYXNQZXJtaXNzaW9uID0gKHBlcm1pc3Npb246IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBhdXRoU2VydmljZS5oYXNQZXJtaXNzaW9uKHBlcm1pc3Npb24pXG4gIH1cblxuICBjb25zdCBoYXNBbnlQZXJtaXNzaW9uID0gKHBlcm1pc3Npb25zOiBzdHJpbmdbXSk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBhdXRoU2VydmljZS5oYXNBbnlQZXJtaXNzaW9uKHBlcm1pc3Npb25zKVxuICB9XG5cbiAgY29uc3QgaGFzUm9sZSA9IChyb2xlOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICByZXR1cm4gYXV0aFNlcnZpY2UuZ2V0VXNlclJvbGUoKSA9PT0gcm9sZVxuICB9XG5cbiAgY29uc3QgY2hlY2tTZXNzaW9uID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgYXV0aFNlcnZpY2UuY2hlY2tTZXNzaW9uKClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignU2Vzc2lvbiBjaGVjayBmYWlsZWQ6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGV4dGVuZFNlc3Npb24gPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBhdXRoU2VydmljZS5leHRlbmRTZXNzaW9uKClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignU2Vzc2lvbiBleHRlbnNpb24gZmFpbGVkOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBjb25zdCBnZXRUZW5hbnRDb250ZXh0ID0gKCk6IFRlbmFudEluZm8gfCBudWxsID0+IHtcbiAgICByZXR1cm4gc3RhdGUudGVuYW50XG4gIH1cblxuICBjb25zdCB2YWxpZGF0ZVRlbmFudEFjY2VzcyA9IChyZXF1aXJlZFRlbmFudDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFzdGF0ZS50ZW5hbnQgfHwgIXN0YXRlLmlzQXV0aGVudGljYXRlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS50ZW5hbnQuaWQgPT09IHJlcXVpcmVkVGVuYW50XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxvZ2luLFxuICAgIGxvZ291dCxcbiAgICByZWZyZXNoVXNlcixcbiAgICBoYXNQZXJtaXNzaW9uLFxuICAgIGhhc0FueVBlcm1pc3Npb24sXG4gICAgaGFzUm9sZSxcbiAgICBjaGVja1Nlc3Npb24sXG4gICAgZXh0ZW5kU2Vzc2lvbixcbiAgICBnZXRUZW5hbnRDb250ZXh0LFxuICAgIHZhbGlkYXRlVGVuYW50QWNjZXNzXG4gIH1cbn1cblxuZXhwb3J0IHsgQXV0aENvbnRleHQgfSJdLCJuYW1lcyI6WyJBdXRoQ29udGV4dCIsInVzZUF1dGgiLCJ1c2VBdXRoQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1bmRlZmluZWQiLCJjb250ZXh0IiwidXNlQ29udGV4dCIsIkVycm9yIiwic3RhdGUiLCJzZXRTdGF0ZSIsInVzZVN0YXRlIiwidXNlciIsInRlbmFudCIsInBlcm1pc3Npb25zIiwiaXNMb2FkaW5nIiwiaXNBdXRoZW50aWNhdGVkIiwiaXNJbml0aWFsaXplZCIsInVzZUVmZmVjdCIsImluaXRpYWxpemVBdXRoIiwid2luZG93IiwiZW5zdXJlVGltZXJGdW5jdGlvbnMiLCJhdXRoU2VydmljZSIsImluaXRpYWxpemVBdXRvUmVmcmVzaCIsImluaXRpYWxpemVBY3Rpdml0eVRyYWNraW5nIiwicmVmcmVzaEludGVydmFsIiwiX19hdXRoUmVmcmVzaEludGVydmFsIiwidGltZW91dEludGVydmFsIiwiX19zZXNzaW9uVGltZW91dEludGVydmFsIiwic2FmZUNsZWFySW50ZXJ2YWwiLCJwcmV2IiwidXNlclJlc3BvbnNlIiwiZ2V0Q3VycmVudFVzZXIiLCJnZXRVc2VyUGVybWlzc2lvbnMiLCJlcnJvciIsImNvbnNvbGUiLCJsb2dvdXQiLCJsb2dpbiIsImxvZ2luRGF0YSIsInJlc3BvbnNlIiwiYWxsRGV2aWNlcyIsIndhcm4iLCJyZWZyZXNoVXNlciIsImhhc1Blcm1pc3Npb24iLCJwZXJtaXNzaW9uIiwiaGFzQW55UGVybWlzc2lvbiIsImhhc1JvbGUiLCJyb2xlIiwiZ2V0VXNlclJvbGUiLCJjaGVja1Nlc3Npb24iLCJleHRlbmRTZXNzaW9uIiwiZ2V0VGVuYW50Q29udGV4dCIsInZhbGlkYXRlVGVuYW50QWNjZXNzIiwicmVxdWlyZWRUZW5hbnQiLCJpZCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztJQTZRU0EsV0FBVztlQUFYQTs7SUExTklDLE9BQU87ZUFBUEE7O0lBUkFDLGNBQWM7ZUFBZEE7Ozt1QkF6Q2tEO3NCQUVuQzs0QkFDNEI7QUFvQ3hELE1BQU1GLGNBQWNHLElBQUFBLG9CQUFhLEVBQThCQztBQUV4RCxNQUFNRixpQkFBaUI7SUFDNUIsTUFBTUcsVUFBVUMsSUFBQUEsaUJBQVUsRUFBQ047SUFDM0IsSUFBSSxDQUFDSyxTQUFTO1FBQ1osTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Y7QUFDVDtBQUVPLE1BQU1KLFVBQVU7SUFDckIsTUFBTSxDQUFDTyxPQUFPQyxTQUFTLEdBQUdDLElBQUFBLGVBQVEsRUFBWTtRQUM1Q0MsTUFBTTtRQUNOQyxRQUFRO1FBQ1JDLGFBQWEsRUFBRTtRQUNmQyxXQUFXO1FBQ1hDLGlCQUFpQjtRQUNqQkMsZUFBZTtJQUNqQjtJQUVBQyxJQUFBQSxnQkFBUyxFQUFDO1FBQ1JDO0lBQ0YsR0FBRyxFQUFFO0lBRUwsa0VBQWtFO0lBQ2xFRCxJQUFBQSxnQkFBUyxFQUFDO1FBQ1IsSUFBSSxPQUFPRSxXQUFXLGFBQWE7WUFDakMsNkRBQTZEO1lBQzdEQyxJQUFBQSxnQ0FBb0I7WUFFcEIsZ0RBQWdEO1lBQ2hEQyxpQkFBVyxDQUFDQyxxQkFBcUI7WUFDakNELGlCQUFXLENBQUNFLDBCQUEwQjtZQUV0Qyw4REFBOEQ7WUFDOUQsT0FBTztnQkFDTCxNQUFNQyxrQkFBa0IsQUFBQ0wsT0FBZU0scUJBQXFCO2dCQUM3RCxNQUFNQyxrQkFBa0IsQUFBQ1AsT0FBZVEsd0JBQXdCO2dCQUVoRSxJQUFJSCxpQkFBaUI7b0JBQ25CSSxJQUFBQSw2QkFBaUIsRUFBQ0o7b0JBQ2xCLE9BQU8sQUFBQ0wsT0FBZU0scUJBQXFCO2dC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