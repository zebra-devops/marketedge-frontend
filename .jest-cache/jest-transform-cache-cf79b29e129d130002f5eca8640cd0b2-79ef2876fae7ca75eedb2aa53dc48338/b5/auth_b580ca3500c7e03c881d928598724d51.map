{"version":3,"sources":["/Users/matt/Sites/MarketEdge/platform-wrapper/frontend/src/services/auth.ts"],"sourcesContent":["import { apiService } from './api'\nimport { LoginRequest, TokenResponse, User } from '@/types/auth'\nimport Cookies from 'js-cookie'\n\ninterface EnhancedTokenResponse {\n  access_token: string\n  refresh_token: string\n  token_type: string\n  expires_in: number\n  user: User\n  tenant: {\n    id: string\n    name: string\n    industry: string\n    subscription_plan: string\n  }\n  permissions: string[]\n}\n\ninterface EnhancedUserResponse {\n  user: User & {\n    created_at?: string\n    updated_at?: string\n  }\n  tenant: {\n    id: string\n    name: string\n    industry: string\n    subscription_plan: string\n  }\n  permissions: string[]\n  session: {\n    authenticated: boolean\n    tenant_isolated: boolean\n  }\n}\n\ninterface LogoutRequest {\n  refresh_token?: string\n  all_devices?: boolean\n}\n\nexport class AuthService {\n  private refreshTokenPromise: Promise<EnhancedTokenResponse> | null = null\n  private readonly tokenRefreshThreshold = 5 * 60 * 1000 // 5 minutes in milliseconds\n\n  async login(loginData: LoginRequest & { state?: string }): Promise<EnhancedTokenResponse> {\n    const response = await apiService.post<EnhancedTokenResponse>('/auth/login', loginData)\n    \n    // Store token metadata\n    this.setTokens(response)\n    this.setUserData(response.user, response.tenant, response.permissions)\n    \n    return response\n  }\n\n  async refreshToken(): Promise<EnhancedTokenResponse> {\n    // Prevent multiple concurrent refresh requests\n    if (this.refreshTokenPromise) {\n      return this.refreshTokenPromise\n    }\n\n    const refreshToken = this.getRefreshToken()\n    if (!refreshToken) {\n      throw new Error('No refresh token available')\n    }\n\n    this.refreshTokenPromise = apiService.post<EnhancedTokenResponse>('/auth/refresh', {\n      refresh_token: refreshToken\n    })\n\n    try {\n      const response = await this.refreshTokenPromise\n      this.setTokens(response)\n      this.setUserData(response.user, response.tenant, response.permissions)\n      return response\n    } catch (error) {\n      // If refresh fails, clear tokens and redirect to login\n      this.clearTokens()\n      throw error\n    } finally {\n      this.refreshTokenPromise = null\n    }\n  }\n\n  async getCurrentUser(): Promise<EnhancedUserResponse> {\n    try {\n      return await apiService.get<EnhancedUserResponse>('/auth/me')\n    } catch (error: any) {\n      if (error?.response?.status === 401) {\n        // Try to refresh token and retry\n        try {\n          await this.refreshToken()\n          return await apiService.get<EnhancedUserResponse>('/auth/me')\n        } catch (refreshError) {\n          this.clearTokens()\n          throw refreshError\n        }\n      }\n      throw error\n    }\n  }\n\n  async getAuth0Url(redirectUri: string, additionalScopes?: string[], organizationHint?: string): Promise<{\n    auth_url: string\n    redirect_uri: string\n    scopes: string[]\n    organization_hint?: string\n  }> {\n    const params = new URLSearchParams({\n      redirect_uri: redirectUri\n    })\n    \n    if (additionalScopes?.length) {\n      params.append('additional_scopes', additionalScopes.join(','))\n    }\n\n    if (organizationHint) {\n      params.append('organization_hint', organizationHint)\n    }\n\n    return apiService.get<{\n      auth_url: string\n      redirect_uri: string\n      scopes: string[]\n      organization_hint?: string\n    }>(`/auth/auth0-url?${params}`)\n  }\n\n  async logout(allDevices: boolean = false): Promise<void> {\n    const refreshToken = this.getRefreshToken()\n    \n    try {\n      await apiService.post('/auth/logout', {\n        refresh_token: refreshToken,\n        all_devices: allDevices\n      } as LogoutRequest)\n    } catch (error) {\n      console.warn('Logout API call failed:', error)\n      // Continue with local cleanup even if server logout fails\n    }\n\n    // Enhanced session cleanup\n    this.performCompleteSessionCleanup()\n    \n    // Redirect to login page\n    window.location.href = '/login'\n  }\n\n  private performCompleteSessionCleanup(): void {\n    // Clear tokens and user data\n    this.clearTokens()\n    this.clearUserData()\n\n    // Clear all localStorage with auth-related data\n    const keysToRemove = [\n      'current_user',\n      'tenant_info', \n      'user_permissions',\n      'token_expires_at',\n      'auth_state',\n      'last_activity'\n    ]\n    \n    keysToRemove.forEach(key => {\n      localStorage.removeItem(key)\n    })\n\n    // Clear all sessionStorage\n    sessionStorage.clear()\n\n    // Clear intervals\n    if (typeof window !== 'undefined') {\n      const refreshInterval = (window as any).__authRefreshInterval\n      const timeoutInterval = (window as any).__sessionTimeoutInterval\n      \n      if (refreshInterval) {\n        clearInterval(refreshInterval)\n        delete (window as any).__authRefreshInterval\n      }\n      \n      if (timeoutInterval) {\n        clearInterval(timeoutInterval)\n        delete (window as any).__sessionTimeoutInterval\n      }\n    }\n\n    // Clear any cached data from API service\n    if ((apiService as any).clearCache) {\n      (apiService as any).clearCache()\n    }\n\n    // Clear browser history state related to auth\n    if (typeof window !== 'undefined' && window.history.replaceState) {\n      const currentUrl = window.location.pathname\n      window.history.replaceState(null, '', currentUrl)\n    }\n\n    console.info('Complete session cleanup performed')\n  }\n\n  async checkSession(): Promise<{\n    authenticated: boolean\n    user_id: string\n    tenant_id: string\n    role: string\n    active: boolean\n  }> {\n    return apiService.get('/auth/session/check')\n  }\n\n  async extendSession(): Promise<{\n    extend_recommended: boolean\n    message: string\n    expires_soon: boolean\n  }> {\n    return apiService.post('/auth/session/extend')\n  }\n\n  getToken(): string | undefined {\n    return Cookies.get('access_token')\n  }\n\n  getRefreshToken(): string | undefined {\n    return Cookies.get('refresh_token')\n  }\n\n  isAuthenticated(): boolean {\n    const token = this.getToken()\n    const user = this.getStoredUser()\n    return !!(token && user)\n  }\n\n  getUserPermissions(): string[] {\n    try {\n      const permissions = localStorage.getItem('user_permissions')\n      return permissions ? JSON.parse(permissions) : []\n    } catch {\n      return []\n    }\n  }\n\n  hasPermission(permission: string): boolean {\n    const permissions = this.getUserPermissions()\n    return permissions.includes(permission)\n  }\n\n  hasAnyPermission(requiredPermissions: string[]): boolean {\n    const userPermissions = this.getUserPermissions()\n    return requiredPermissions.some(perm => userPermissions.includes(perm))\n  }\n\n  getUserRole(): string | null {\n    const user = this.getStoredUser()\n    return user?.role || null\n  }\n\n  getTenantInfo(): { id: string; name: string; industry: string; subscription_plan: string } | null {\n    try {\n      const tenantData = localStorage.getItem('tenant_info')\n      return tenantData ? JSON.parse(tenantData) : null\n    } catch {\n      return null\n    }\n  }\n\n  shouldRefreshToken(): boolean {\n    // Check if we should proactively refresh the token\n    const tokenExpiry = localStorage.getItem('token_expires_at')\n    if (!tokenExpiry) return false\n\n    const expiryTime = new Date(tokenExpiry).getTime()\n    const currentTime = Date.now()\n    \n    return (expiryTime - currentTime) <= this.tokenRefreshThreshold\n  }\n\n  // Auto-refresh token if needed\n  async ensureValidToken(): Promise<string | null> {\n    const token = this.getToken()\n    if (!token) return null\n\n    if (this.shouldRefreshToken()) {\n      try {\n        await this.refreshToken()\n        return this.getToken()\n      } catch (error) {\n        console.error('Token refresh failed:', error)\n        return null\n      }\n    }\n\n    return token\n  }\n\n  private setTokens(tokenResponse: EnhancedTokenResponse): void {\n    // Set HTTP-only cookies are handled by the server\n    // Store token expiry for refresh logic\n    const expiryTime = new Date(Date.now() + (tokenResponse.expires_in * 1000))\n    localStorage.setItem('token_expires_at', expiryTime.toISOString())\n  }\n\n  private setUserData(user: User, tenant: any, permissions: string[]): void {\n    localStorage.setItem('current_user', JSON.stringify(user))\n    localStorage.setItem('tenant_info', JSON.stringify(tenant))\n    localStorage.setItem('user_permissions', JSON.stringify(permissions))\n  }\n\n  private getStoredUser(): User | null {\n    try {\n      const userData = localStorage.getItem('current_user')\n      return userData ? JSON.parse(userData) : null\n    } catch {\n      return null\n    }\n  }\n\n  private clearTokens(): void {\n    Cookies.remove('access_token')\n    Cookies.remove('refresh_token')\n    localStorage.removeItem('token_expires_at')\n  }\n\n  private clearUserData(): void {\n    localStorage.removeItem('current_user')\n    localStorage.removeItem('tenant_info')\n    localStorage.removeItem('user_permissions')\n  }\n\n  // Enhanced auto-refresh with tenant validation and better error handling\n  initializeAutoRefresh(): void {\n    if (!this.isAuthenticated() || process.env.NODE_ENV === 'test') return\n\n    // Check token status every minute\n    const refreshInterval = setInterval(() => {\n      if (!this.isAuthenticated()) {\n        clearInterval(refreshInterval)\n        return\n      }\n\n      if (this.shouldRefreshToken()) {\n        this.refreshToken().catch(error => {\n          console.error('Background token refresh failed:', error)\n          \n          // If refresh fails due to invalid token, clear session and redirect\n          if (error?.response?.status === 401) {\n            console.warn('Session expired, redirecting to login')\n            this.clearTokens()\n            this.clearUserData()\n            window.location.href = '/login'\n          }\n        })\n      }\n    }, 60000) // Check every minute\n\n    // Store interval ID for cleanup\n    if (typeof window !== 'undefined') {\n      (window as any).__authRefreshInterval = refreshInterval\n    }\n  }\n\n  // Enhanced session timeout detection\n  private sessionTimeoutThreshold = 30 * 60 * 1000 // 30 minutes\n  private lastActivityTime = Date.now()\n\n  trackUserActivity(): void {\n    this.lastActivityTime = Date.now()\n  }\n\n  checkSessionTimeout(): boolean {\n    const now = Date.now()\n    const timeSinceLastActivity = now - this.lastActivityTime\n    return timeSinceLastActivity > this.sessionTimeoutThreshold\n  }\n\n  initializeActivityTracking(): void {\n    if (typeof window === 'undefined' || process.env.NODE_ENV === 'test') return\n\n    // Track user activity\n    const activityEvents = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click']\n    \n    const handleActivity = () => {\n      this.trackUserActivity()\n    }\n\n    activityEvents.forEach(event => {\n      document.addEventListener(event, handleActivity, { passive: true })\n    })\n\n    // Check for session timeout every 5 minutes\n    const timeoutCheckInterval = setInterval(() => {\n      if (!this.isAuthenticated()) {\n        clearInterval(timeoutCheckInterval)\n        return\n      }\n\n      if (this.checkSessionTimeout()) {\n        console.warn('Session timeout due to inactivity')\n        this.logout()\n      }\n    }, 5 * 60 * 1000) // Check every 5 minutes\n\n    // Store interval ID for cleanup\n    (window as any).__sessionTimeoutInterval = timeoutCheckInterval\n  }\n}\n\nexport const authService = new AuthService()\n\n// Initialize auto-refresh and activity tracking on module load\nif (typeof window !== 'undefined') {\n  authService.initializeAutoRefresh()\n  authService.initializeActivityTracking()\n}"],"names":["AuthService","authService","login","loginData","response","apiService","post","setTokens","setUserData","user","tenant","permissions","refreshToken","refreshTokenPromise","getRefreshToken","Error","refresh_token","error","clearTokens","getCurrentUser","get","status","refreshError","getAuth0Url","redirectUri","additionalScopes","organizationHint","params","URLSearchParams","redirect_uri","length","append","join","logout","allDevices","all_devices","console","warn","performCompleteSessionCleanup","window","location","href","clearUserData","keysToRemove","forEach","key","localStorage","removeItem","sessionStorage","clear","refreshInterval","__authRefreshInterval","timeoutInterval","__sessionTimeoutInterval","clearInterval","clearCache","history","replaceState","currentUrl","pathname","info","checkSession","extendSession","getToken","Cookies","isAuthenticated","token","getStoredUser","getUserPermissions","getItem","JSON","parse","hasPermission","permission","includes","hasAnyPermission","requiredPermissions","userPermissions","some","perm","getUserRole","role","getTenantInfo","tenantData","shouldRefreshToken","tokenExpiry","expiryTime","Date","getTime","currentTime","now","tokenRefreshThreshold","ensureValidToken","tokenResponse","expires_in","setItem","toISOString","stringify","userData","remove","initializeAutoRefresh","process","env","NODE_ENV","setInterval","catch","trackUserActivity","lastActivityTime","checkSessionTimeout","timeSinceLastActivity","sessionTimeoutThreshold","initializeActivityTracking","activityEvents","handleActivity","event","document","addEventListener","passive","timeoutCheckInterval"],"mappings":"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"}