{"version":3,"sources":["/Users/matt/Sites/MarketEdge/platform-wrapper/frontend/src/services/auth.ts"],"sourcesContent":["import { apiService } from './api'\nimport { LoginRequest, TokenResponse, User } from '@/types/auth'\nimport Cookies from 'js-cookie'\nimport { safeClearInterval, safeSetInterval, ensureTimerFunctions } from '@/utils/timer-utils'\n\ninterface EnhancedTokenResponse {\n  access_token: string\n  refresh_token: string\n  token_type: string\n  expires_in: number\n  user: User\n  tenant: {\n    id: string\n    name: string\n    industry: string\n    subscription_plan: string\n  }\n  permissions: string[]\n}\n\ninterface EnhancedUserResponse {\n  user: User & {\n    created_at?: string\n    updated_at?: string\n  }\n  tenant: {\n    id: string\n    name: string\n    industry: string\n    subscription_plan: string\n  }\n  permissions: string[]\n  session: {\n    authenticated: boolean\n    tenant_isolated: boolean\n  }\n}\n\ninterface LogoutRequest {\n  refresh_token?: string\n  all_devices?: boolean\n}\n\nexport class AuthService {\n  private refreshTokenPromise: Promise<EnhancedTokenResponse> | null = null\n  private loginPromise: Promise<EnhancedTokenResponse> | null = null\n  private readonly tokenRefreshThreshold = 5 * 60 * 1000 // 5 minutes in milliseconds\n  private processedAuthCodes: Set<string> = new Set()\n\n  async login(loginData: LoginRequest & { state?: string }): Promise<EnhancedTokenResponse> {\n    // EMERGENCY CIRCUIT BREAKER: Prevent duplicate requests with the same auth code\n    if (this.processedAuthCodes.has(loginData.code)) {\n      console.error('EMERGENCY CIRCUIT BREAKER: Authentication code has already been processed:', loginData.code.substring(0, 10) + '...')\n      throw new Error('Authentication code has already been processed')\n    }\n\n    // EMERGENCY CIRCUIT BREAKER: Prevent multiple concurrent login requests\n    if (this.loginPromise) {\n      console.error('EMERGENCY CIRCUIT BREAKER: Login already in progress, rejecting duplicate request')\n      throw new Error('Login already in progress')\n    }\n\n    // Mark this auth code as being processed IMMEDIATELY\n    this.processedAuthCodes.add(loginData.code)\n    console.log('EMERGENCY CIRCUIT BREAKER: Auth code marked as processed:', loginData.code.substring(0, 10) + '...')\n\n    console.log('Initiating login request to backend')\n    \n    this.loginPromise = (async () => {\n      try {\n        const response = await apiService.post<EnhancedTokenResponse>('/auth/login', loginData)\n        \n        console.log('Login response received from backend')\n        \n        // Store token metadata\n        this.setTokens(response)\n        this.setUserData(response.user, response.tenant, response.permissions)\n        \n        // Clean up processed auth codes (keep only recent ones to prevent memory leak)\n        if (this.processedAuthCodes.size > 10) {\n          this.processedAuthCodes.clear()\n        }\n        \n        return response\n      } catch (error: any) {\n        // Remove the failed auth code from processed set to allow retry\n        this.processedAuthCodes.delete(loginData.code)\n        \n        console.error('Login request failed:', error)\n        \n        // Handle specific backend errors\n        if (error?.response?.status === 429) {\n          throw new Error('Too many login attempts. Please wait and try again.')\n        } else if (error?.response?.status === 400) {\n          throw new Error('Invalid authorization code. Please try logging in again.')\n        } else if (error?.response?.status === 401) {\n          throw new Error('Authentication failed. Please try logging in again.')\n        } else if (error?.message?.includes('ERR_INSUFFICIENT_RESOURCES')) {\n          throw new Error('Server overloaded. Please wait and try again.')\n        }\n        \n        throw error\n      } finally {\n        // Clear the login promise after completion\n        this.loginPromise = null\n      }\n    })()\n\n    return this.loginPromise\n  }\n\n  async refreshToken(): Promise<EnhancedTokenResponse> {\n    // Prevent multiple concurrent refresh requests\n    if (this.refreshTokenPromise) {\n      return this.refreshTokenPromise\n    }\n\n    const refreshToken = this.getRefreshToken()\n    if (!refreshToken) {\n      throw new Error('No refresh token available')\n    }\n\n    this.refreshTokenPromise = apiService.post<EnhancedTokenResponse>('/auth/refresh', {\n      refresh_token: refreshToken\n    })\n\n    try {\n      const response = await this.refreshTokenPromise\n      this.setTokens(response)\n      this.setUserData(response.user, response.tenant, response.permissions)\n      return response\n    } catch (error) {\n      // If refresh fails, clear tokens and redirect to login\n      this.clearTokens()\n      throw error\n    } finally {\n      this.refreshTokenPromise = null\n    }\n  }\n\n  async getCurrentUser(): Promise<EnhancedUserResponse> {\n    try {\n      return await apiService.get<EnhancedUserResponse>('/auth/me')\n    } catch (error: any) {\n      if (error?.response?.status === 401) {\n        // Try to refresh token and retry\n        try {\n          await this.refreshToken()\n          return await apiService.get<EnhancedUserResponse>('/auth/me')\n        } catch (refreshError) {\n          this.clearTokens()\n          throw refreshError\n        }\n      }\n      throw error\n    }\n  }\n\n  async getAuth0Url(redirectUri: string, additionalScopes?: string[], organizationHint?: string): Promise<{\n    auth_url: string\n    redirect_uri: string\n    scopes: string[]\n    organization_hint?: string\n  }> {\n    const params = new URLSearchParams({\n      redirect_uri: redirectUri\n    })\n    \n    if (additionalScopes?.length) {\n      params.append('additional_scopes', additionalScopes.join(','))\n    }\n\n    if (organizationHint) {\n      params.append('organization_hint', organizationHint)\n    }\n\n    return apiService.get<{\n      auth_url: string\n      redirect_uri: string\n      scopes: string[]\n      organization_hint?: string\n    }>(`/auth/auth0-url?${params}`)\n  }\n\n  async logout(allDevices: boolean = false): Promise<void> {\n    const refreshToken = this.getRefreshToken()\n    \n    try {\n      await apiService.post('/auth/logout', {\n        refresh_token: refreshToken,\n        all_devices: allDevices\n      } as LogoutRequest)\n    } catch (error) {\n      console.warn('Logout API call failed:', error)\n      // Continue with local cleanup even if server logout fails\n    }\n\n    // Enhanced session cleanup\n    this.performCompleteSessionCleanup()\n    \n    // Redirect to login page\n    window.location.href = '/login'\n  }\n\n  private performCompleteSessionCleanup(): void {\n    // Clear tokens and user data\n    this.clearTokens()\n    this.clearUserData()\n\n    // Clear all localStorage with auth-related data\n    const keysToRemove = [\n      'current_user',\n      'tenant_info', \n      'user_permissions',\n      'token_expires_at',\n      'auth_state',\n      'last_activity'\n    ]\n    \n    keysToRemove.forEach(key => {\n      localStorage.removeItem(key)\n    })\n\n    // Clear all sessionStorage\n    sessionStorage.clear()\n\n    // Clear intervals\n    if (typeof window !== 'undefined') {\n      const refreshInterval = (window as any).__authRefreshInterval\n      const timeoutInterval = (window as any).__sessionTimeoutInterval\n      \n      if (refreshInterval) {\n        safeClearInterval(refreshInterval)\n        delete (window as any).__authRefreshInterval\n      }\n      \n      if (timeoutInterval) {\n        safeClearInterval(timeoutInterval)\n        delete (window as any).__sessionTimeoutInterval\n      }\n    }\n\n    // Clear any cached data from API service\n    if ((apiService as any).clearCache) {\n      (apiService as any).clearCache()\n    }\n\n    // Clear browser history state related to auth\n    if (typeof window !== 'undefined' && window.history.replaceState) {\n      const currentUrl = window.location.pathname\n      window.history.replaceState(null, '', currentUrl)\n    }\n\n    console.info('Complete session cleanup performed')\n  }\n\n  async checkSession(): Promise<{\n    authenticated: boolean\n    user_id: string\n    tenant_id: string\n    role: string\n    active: boolean\n  }> {\n    return apiService.get('/auth/session/check')\n  }\n\n  async extendSession(): Promise<{\n    extend_recommended: boolean\n    message: string\n    expires_soon: boolean\n  }> {\n    return apiService.post('/auth/session/extend')\n  }\n\n  getToken(): string | undefined {\n    return Cookies.get('access_token')\n  }\n\n  getRefreshToken(): string | undefined {\n    return Cookies.get('refresh_token')\n  }\n\n  isAuthenticated(): boolean {\n    const token = this.getToken()\n    const user = this.getStoredUser()\n    return !!(token && user)\n  }\n\n  getUserPermissions(): string[] {\n    try {\n      const permissions = localStorage.getItem('user_permissions')\n      return permissions ? JSON.parse(permissions) : []\n    } catch {\n      return []\n    }\n  }\n\n  hasPermission(permission: string): boolean {\n    const permissions = this.getUserPermissions()\n    return permissions.includes(permission)\n  }\n\n  hasAnyPermission(requiredPermissions: string[]): boolean {\n    const userPermissions = this.getUserPermissions()\n    return requiredPermissions.some(perm => userPermissions.includes(perm))\n  }\n\n  getUserRole(): string | null {\n    const user = this.getStoredUser()\n    return user?.role || null\n  }\n\n  getTenantInfo(): { id: string; name: string; industry: string; subscription_plan: string } | null {\n    try {\n      const tenantData = localStorage.getItem('tenant_info')\n      return tenantData ? JSON.parse(tenantData) : null\n    } catch {\n      return null\n    }\n  }\n\n  shouldRefreshToken(): boolean {\n    // Check if we should proactively refresh the token\n    const tokenExpiry = localStorage.getItem('token_expires_at')\n    if (!tokenExpiry) return false\n\n    const expiryTime = new Date(tokenExpiry).getTime()\n    const currentTime = Date.now()\n    \n    return (expiryTime - currentTime) <= this.tokenRefreshThreshold\n  }\n\n  // Auto-refresh token if needed\n  async ensureValidToken(): Promise<string | null> {\n    const token = this.getToken()\n    if (!token) return null\n\n    if (this.shouldRefreshToken()) {\n      try {\n        await this.refreshToken()\n        return this.getToken()\n      } catch (error) {\n        console.error('Token refresh failed:', error)\n        return null\n      }\n    }\n\n    return token\n  }\n\n  private setTokens(tokenResponse: EnhancedTokenResponse): void {\n    // Set HTTP-only cookies are handled by the server\n    // Store token expiry for refresh logic with defensive validation\n    try {\n      const expiresInSeconds = tokenResponse.expires_in || 3600 // Default to 1 hour if not provided\n      const expiresInMilliseconds = Number(expiresInSeconds) * 1000\n      \n      // Validate that we have a valid number\n      if (isNaN(expiresInMilliseconds) || expiresInMilliseconds <= 0) {\n        throw new Error(`Invalid expires_in value: ${tokenResponse.expires_in}`)\n      }\n      \n      const expiryTime = new Date(Date.now() + expiresInMilliseconds)\n      \n      // Validate the date is valid before converting to ISO string\n      if (isNaN(expiryTime.getTime())) {\n        throw new Error(`Invalid expiry date calculated from expires_in: ${tokenResponse.expires_in}`)\n      }\n      \n      localStorage.setItem('token_expires_at', expiryTime.toISOString())\n      \n      console.log(`Token expiry set: ${expiryTime.toISOString()} (expires_in: ${expiresInSeconds}s)`)\n    } catch (error) {\n      console.error('Error setting token expiry time:', error)\n      // Fallback: set expiry to 1 hour from now\n      const fallbackExpiry = new Date(Date.now() + 3600000) // 1 hour\n      localStorage.setItem('token_expires_at', fallbackExpiry.toISOString())\n      console.warn(`Using fallback token expiry: ${fallbackExpiry.toISOString()}`)\n    }\n  }\n\n  private setUserData(user: User, tenant: any, permissions: string[]): void {\n    localStorage.setItem('current_user', JSON.stringify(user))\n    localStorage.setItem('tenant_info', JSON.stringify(tenant))\n    localStorage.setItem('user_permissions', JSON.stringify(permissions))\n  }\n\n  private getStoredUser(): User | null {\n    try {\n      const userData = localStorage.getItem('current_user')\n      return userData ? JSON.parse(userData) : null\n    } catch {\n      return null\n    }\n  }\n\n  private clearTokens(): void {\n    Cookies.remove('access_token')\n    Cookies.remove('refresh_token')\n    localStorage.removeItem('token_expires_at')\n  }\n\n  private clearUserData(): void {\n    localStorage.removeItem('current_user')\n    localStorage.removeItem('tenant_info')\n    localStorage.removeItem('user_permissions')\n  }\n\n  // Enhanced auto-refresh with tenant validation and better error handling\n  initializeAutoRefresh(): void {\n    if (!this.isAuthenticated() || process.env.NODE_ENV === 'test' || typeof window === 'undefined') {\n      return\n    }\n\n    // Ensure timer functions are available in production\n    ensureTimerFunctions()\n\n    // Clear existing interval if it exists\n    const existingInterval = (window as any).__authRefreshInterval\n    if (existingInterval) {\n      safeClearInterval(existingInterval)\n      delete (window as any).__authRefreshInterval\n    }\n\n    // Check token status every minute\n    const refreshInterval = safeSetInterval(() => {\n      if (!this.isAuthenticated()) {\n        safeClearInterval(refreshInterval)\n        if (typeof window !== 'undefined') {\n          delete (window as any).__authRefreshInterval\n        }\n        return\n      }\n\n      if (this.shouldRefreshToken()) {\n        this.refreshToken().catch(error => {\n          console.error('Background token refresh failed:', error)\n          \n          // If refresh fails due to invalid token, clear session and redirect\n          if (error?.response?.status === 401) {\n            console.warn('Session expired, redirecting to login')\n            this.clearTokens()\n            this.clearUserData()\n            window.location.href = '/login'\n          }\n        })\n      }\n    }, 60000) // Check every minute\n\n    // Store interval ID for cleanup\n    (window as any).__authRefreshInterval = refreshInterval\n  }\n\n  // Enhanced session timeout detection\n  private sessionTimeoutThreshold = 30 * 60 * 1000 // 30 minutes\n  private lastActivityTime = Date.now()\n\n  trackUserActivity(): void {\n    this.lastActivityTime = Date.now()\n  }\n\n  checkSessionTimeout(): boolean {\n    const now = Date.now()\n    const timeSinceLastActivity = now - this.lastActivityTime\n    return timeSinceLastActivity > this.sessionTimeoutThreshold\n  }\n\n  initializeActivityTracking(): void {\n    // EMERGENCY FIX: Activity tracking disabled to resolve persistent setInterval production errors\n    // This prevents the \"TypeError: setInterval(...) is not a function\" error in production\n    console.log('Activity tracking disabled - emergency production fix')\n    \n    // Simple activity tracking without timers - just update activity time on page load\n    if (typeof window !== 'undefined' && process.env.NODE_ENV !== 'test') {\n      this.trackUserActivity()\n    }\n    \n    return\n  }\n}\n\nexport const authService = new AuthService()\n\n// Note: Timer initialization moved to client-side components to prevent SSR issues"],"names":["AuthService","authService","login","loginData","processedAuthCodes","has","code","console","error","substring","Error","loginPromise","add","log","response","apiService","post","setTokens","setUserData","user","tenant","permissions","size","clear","delete","status","message","includes","refreshToken","refreshTokenPromise","getRefreshToken","refresh_token","clearTokens","getCurrentUser","get","refreshError","getAuth0Url","redirectUri","additionalScopes","organizationHint","params","URLSearchParams","redirect_uri","length","append","join","logout","allDevices","all_devices","warn","performCompleteSessionCleanup","window","location","href","clearUserData","keysToRemove","forEach","key","localStorage","removeItem","sessionStorage","refreshInterval","__authRefreshInterval","timeoutInterval","__sessionTimeoutInterval","safeClearInterval","clearCache","history","replaceState","currentUrl","pathname","info","checkSession","extendSession","getToken","Cookies","isAuthenticated","token","getStoredUser","getUserPermissions","getItem","JSON","parse","hasPermission","permission","hasAnyPermission","requiredPermissions","userPermissions","some","perm","getUserRole","role","getTenantInfo","tenantData","shouldRefreshToken","tokenExpiry","expiryTime","Date","getTime","currentTime","now","tokenRefreshThreshold","ensureValidToken","tokenResponse","expiresInSeconds","expires_in","expiresInMilliseconds","Number","isNaN","setItem","toISOString","fallbackExpiry","stringify","userData","remove","initializeAutoRefresh","process","env","NODE_ENV","ensureTimerFunctions","existingInterval","safeSetInterval","catch","trackUserActivity","lastActivityTime","checkSessionTimeout","timeSinceLastActivity","sessionTimeoutThreshold","initializeActivityTracking","Set"],"mappings":";;;;;;;;;;;IA2CaA,WAAW;eAAXA;;IAsbAC,WAAW;eAAXA;;;qBAjec;iEAEP;4BACqD;;;;;;AAwClE,MAAMD;IAMX,MAAME,MAAMC,SAA4C,EAAkC;QACxF,gFAAgF;QAChF,IAAI,IAAI,CAACC,kBAAkB,CAACC,GAAG,CAACF,UAAUG,IAAI,GAAG;YAC/CC,QAAQC,KAAK,CAAC,8EAA8EL,UAAUG,IAAI,CAACG,SAAS,CAAC,GAAG,MAAM;YAC9H,MAAM,IAAIC,MAAM;QAClB;QAEA,wEAAwE;QACxE,IAAI,IAAI,CAACC,YAAY,EAAE;YACrBJ,QAAQC,KAAK,CAAC;YACd,MAAM,IAAIE,MAAM;QAClB;QAEA,qDAAqD;QACrD,IAAI,CAACN,kBAAkB,CAACQ,GAAG,CAACT,UAAUG,IAAI;QAC1CC,QAAQM,GAAG,CAAC,6DAA6DV,UAAUG,IAAI,CAACG,SAAS,CAAC,GAAG,MAAM;QAE3GF,QAAQM,GAAG,CAAC;QAEZ,IAAI,CAACF,YAAY,GAAG,AAAC,CAAA;YACnB,IAAI;gBACF,MAAMG,WAAW,MAAMC,eAAU,CAACC,IAAI,CAAwB,eAAeb;gBAE7EI,QAAQM,GAAG,CAAC;gBAEZ,uBAAuB;gBACvB,IAAI,CAACI,SAAS,CAACH;gBACf,IAAI,CAACI,WAAW,CAACJ,SAASK,IAAI,EAAEL,SAASM,MAAM,EAAEN,SAASO,WAAW;gBAErE,+EAA+E;gBAC/E,IAAI,IAAI,CAACjB,kBAAkB,CAACkB,IAAI,GAAG,IAAI;oBACrC,IAAI,CAAClB,kBAAkB,CAACmB,KAAK;gBAC/B;gBAEA,OAAOT;YACT,EAAE,OAAON,OAAY;gBACnB,gEAAgE;gBAChE,IAAI,CAACJ,kBAAkB,CAACoB,MAAM,CAACrB,UAAUG,IAAI;gBAE7CC,QAAQC,KAAK,CAAC,yBAAyBA;gBAEvC,iCAAiC;gBACjC,IAAIA,OAAOM,UAAUW,WAAW,KAAK;oBACnC,MAAM,IAAIf,MAAM;gBAClB,OAAO,IAAIF,OAAOM,UAAUW,WAAW,KAAK;oBAC1C,MAAM,IAAIf,MAAM;gBAClB,OAAO,IAAIF,OAAOM,UAAUW,WAAW,KAAK;oBAC1C,MAAM,IAAIf,MAAM;gBAClB,OAAO,IAAIF,OAAOkB,SAASC,SAAS,+BAA+B;oBACjE,MAAM,IAAIjB,MAAM;gBAClB;gBAEA,MAAMF;YACR,SAAU;gBACR,2CAA2C;gBAC3C,IAAI,CAACG,YAAY,GAAG;YACtB;QACF,CAAA;QAEA,OAAO,IAAI,CAACA,YAAY;IAC1B;IAEA,MAAMiB,eAA+C;QACnD,+CAA+C;QAC/C,IAAI,IAAI,CAACC,mBAAmB,EAAE;YAC5B,OAAO,IAAI,CAACA,mBAAmB;QACjC;QAEA,MAAMD,eAAe,IAAI,CAACE,eAAe;QACzC,IAAI,CAACF,cAAc;YACjB,MAAM,IAAIlB,MAAM;QAClB;QAEA,IAAI,CAACmB,mBAAmB,GAAGd,eAAU,CAACC,IAAI,CAAwB,iBAAiB;YACjFe,eAAeH;QACjB;QAEA,IAAI;YACF,MAAMd,WAAW,MAAM,IAAI,CAACe,mBAAmB;YAC/C,IAAI,CAACZ,SAAS,CAACH;YACf,IAAI,CAACI,WAAW,CAACJ,SAASK,IAAI,EAAEL,SAASM,MAAM,EAAEN,SAASO,WAAW;YACrE,OAAOP;QACT,EAAE,OAAON,OAAO;YACd,uDAAuD;YACvD,IAAI,CAACwB,WAAW;YAChB,MAAMxB;QACR,SAAU;YACR,IAAI,CAACqB,mBAAmB,GAAG;QAC7B;IACF;IAEA,MAAMI,iBAAgD;QACpD,IAAI;YACF,OAAO,MAAMlB,eAAU,CAACmB,GAAG,CAAuB;QACpD,EAAE,OAAO1B,OAAY;YACnB,IAAIA,OAAOM,UAAUW,WAAW,KAAK;gBACnC,iCAAiC;gBACjC,IAAI;oBACF,MAAM,IAAI,CAACG,YAAY;oBACvB,OAAO,MAAMb,eAAU,CAACmB,GAAG,CAAuB;gBACpD,EAAE,OAAOC,cAAc;oBACrB,IAAI,CAACH,WAAW;oBAChB,MAAMG;gBACR;YACF;YACA,MAAM3B;QACR;IACF;IAEA,MAAM4B,YAAYC,WAAmB,EAAEC,gBAA2B,EAAEC,gBAAyB,EAK1F;QACD,MAAMC,SAAS,IAAIC,gBAAgB;YACjCC,cAAcL;QAChB;QAEA,IAAIC,kBAAkBK,QAAQ;YAC5BH,OAAOI,MAAM,CAAC,qBAAqBN,iBAAiBO,IAAI,CAAC;QAC3D;QAEA,IAAIN,kBAAkB;YACpBC,OAAOI,MAAM,CAAC,qBAAqBL;QACrC;QAEA,OAAOxB,eAAU,CAACmB,GAAG,CAKlB,CAAC,gBAAgB,EAAEM,OAAO,CAAC;IAChC;IAEA,MAAMM,OAAOC,aAAsB,KAAK,EAAiB;QACvD,MAAMnB,eAAe,IAAI,CAACE,eAAe;QAEzC,IAAI;YACF,MAAMf,eAAU,CAACC,IAAI,CAAC,gBAAgB;gBACpCe,eAAeH;gBACfoB,aAAaD;YACf;QACF,EAAE,OAAOvC,OAAO;YACdD,QAAQ0C,IAAI,CAAC,2BAA2BzC;QACxC,0DAA0D;QAC5D;QAEA,2BAA2B;QAC3B,IAAI,CAAC0C,6BAA6B;QAElC,yBAAyB;QACzBC,OAAOC,QAAQ,CAACC,IAAI,GAAG;IACzB;IAEQH,gCAAsC;QAC5C,6BAA6B;QAC7B,IAAI,CAAClB,WAAW;QAChB,IAAI,CAACsB,aAAa;QAElB,gDAAgD;QAChD,MAAMC,eAAe;YACnB;YACA;YACA;YACA;YACA;YACA;SACD;QAEDA,aAAaC,OAAO,CAACC,CAAAA;YACnBC,aAAaC,UAAU,CAACF;QAC1B;QAEA,2BAA2B;QAC3BG,eAAerC,KAAK;QAEpB,kBAAkB;QAClB,IAAI,OAAO4B,WAAW,aAAa;YACjC,MAAMU,kBAAkB,AAACV,OAAeW,qBAAqB;YAC7D,MAAMC,kBAAkB,AAACZ,OAAea,wBAAwB;YAEhE,IAAIH,iBAAiB;gBACnBI,IAAAA,6BAAiB,EAACJ;gBAClB,OAAO,AAACV,OAAeW,qBAAqB;YAC9C;YAEA,IAAIC,iBAAiB;gBACnBE,IAAAA,6BAAiB,EAACF;gBAClB,OAAO,AAACZ,OAAea,wBAAwB;YACjD;QACF;QAEA,yCAAyC;QACzC,IAAI,AAACjD,eAAU,CAASmD,UAAU,EAAE;YACjCnD,eAAU,CAASmD,UAAU;QAChC;QAEA,8CAA8C;QAC9C,IAAI,OAAOf,WAAW,eAAeA,OAAOgB,OAAO,CAACC,YAAY,EAAE;YAChE,MAAMC,aAAalB,OAAOC,QAAQ,CAACkB,QAAQ;YAC3CnB,OAAOgB,OAAO,CAACC,YAAY,CAAC,MAAM,IAAIC;QACxC;QAEA9D,QAAQgE,IAAI,CAAC;IACf;IAEA,MAAMC,eAMH;QACD,OAAOzD,eAAU,CAACmB,GAAG,CAAC;IACxB;IAEA,MAAMuC,gBAIH;QACD,OAAO1D,eAAU,CAACC,IAAI,CAAC;IACzB;IAEA0D,WAA+B;QAC7B,OAAOC,iBAAO,CAACzC,GAAG,CAAC;IACrB;IAEAJ,kBAAsC;QACpC,OAAO6C,iBAAO,CAACzC,GAAG,CAAC;IACrB;IAEA0C,kBAA2B;QACzB,MAAMC,QAAQ,IAAI,CAACH,QAAQ;QAC3B,MAAMvD,OAAO,IAAI,CAAC2D,aAAa;QAC/B,OAAO,CAAC,CAAED,CAAAA,SAAS1D,IAAG;IACxB;IAEA4D,qBAA+B;QAC7B,IAAI;YACF,MAAM1D,cAAcqC,aAAasB,OAAO,CAAC;YACzC,OAAO3D,cAAc4D,KAAKC,KAAK,CAAC7D,eAAe,EAAE;QACnD,EAAE,OAAM;YACN,OAAO,EAAE;QACX;IACF;IAEA8D,cAAcC,UAAkB,EAAW;QACzC,MAAM/D,cAAc,IAAI,CAAC0D,kBAAkB;QAC3C,OAAO1D,YAAYM,QAAQ,CAACyD;IAC9B;IAEAC,iBAAiBC,mBAA6B,EAAW;QACvD,MAAMC,kBAAkB,IAAI,CAACR,kBAAkB;QAC/C,OAAOO,oBAAoBE,IAAI,CAACC,CAAAA,OAAQF,gBAAgB5D,QAAQ,CAAC8D;IACnE;IAEAC,cAA6B;QAC3B,MAAMvE,OAAO,IAAI,CAAC2D,aAAa;QAC/B,OAAO3D,MAAMwE,QAAQ;IACvB;IAEAC,gBAAkG;QAChG,IAAI;YACF,MAAMC,aAAanC,aAAasB,OAAO,CAAC;YACxC,OAAOa,aAAaZ,KAAKC,KAAK,CAACW,cAAc;QAC/C,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEAC,qBAA8B;QAC5B,mDAAmD;QACnD,MAAMC,cAAcrC,aAAasB,OAAO,CAAC;QACzC,IAAI,CAACe,aAAa,OAAO;QAEzB,MAAMC,aAAa,IAAIC,KAAKF,aAAaG,OAAO;QAChD,MAAMC,cAAcF,KAAKG,GAAG;QAE5B,OAAO,AAACJ,aAAaG,eAAgB,IAAI,CAACE,qBAAqB;IACjE;IAEA,+BAA+B;IAC/B,MAAMC,mBAA2C;QAC/C,MAAMzB,QAAQ,IAAI,CAACH,QAAQ;QAC3B,IAAI,CAACG,OAAO,OAAO;QAEnB,IAAI,IAAI,CAACiB,kBAAkB,IAAI;YAC7B,IAAI;gBACF,MAAM,IAAI,CAAClE,YAAY;gBACvB,OAAO,IAAI,CAAC8C,QAAQ;YACtB,EAAE,OAAOlE,OAAO;gBACdD,QAAQC,KAAK,CAAC,yBAAyBA;gBACvC,OAAO;YACT;QACF;QAEA,OAAOqE;IACT;IAEQ5D,UAAUsF,aAAoC,EAAQ;QAC5D,kDAAkD;QAClD,iEAAiE;QACjE,IAAI;YACF,MAAMC,mBAAmBD,cAAcE,UAAU,IAAI,KAAK,oCAAoC;;YAC9F,MAAMC,wBAAwBC,OAAOH,oBAAoB;YAEzD,uCAAuC;YACvC,IAAII,MAAMF,0BAA0BA,yBAAyB,GAAG;gBAC9D,MAAM,IAAIhG,MAAM,CAAC,0BAA0B,EAAE6F,cAAcE,UAAU,CAAC,CAAC;YACzE;YAEA,MAAMT,aAAa,IAAIC,KAAKA,KAAKG,GAAG,KAAKM;YAEzC,6DAA6D;YAC7D,IAAIE,MAAMZ,WAAWE,OAAO,KAAK;gBAC/B,MAAM,IAAIxF,MAAM,CAAC,gDAAgD,EAAE6F,cAAcE,UAAU,CAAC,CAAC;YAC/F;YAEA/C,aAAamD,OAAO,CAAC,oBAAoBb,WAAWc,WAAW;YAE/DvG,QAAQM,GAAG,CAAC,CAAC,kBAAkB,EAAEmF,WAAWc,WAAW,GAAG,cAAc,EAAEN,iBAAiB,EAAE,CAAC;QAChG,EAAE,OAAOhG,OAAO;YACdD,QAAQC,KAAK,CAAC,oCAAoCA;YAClD,0CAA0C;YAC1C,MAAMuG,iBAAiB,IAAId,KAAKA,KAAKG,GAAG,KAAK,SAAS,SAAS;;YAC/D1C,aAAamD,OAAO,CAAC,oBAAoBE,eAAeD,WAAW;YACnEvG,QAAQ0C,IAAI,CAAC,CAAC,6BAA6B,EAAE8D,eAAeD,WAAW,GAAG,CAAC;QAC7E;IACF;IAEQ5F,YAAYC,IAAU,EAAEC,MAAW,EAAEC,WAAqB,EAAQ;QACxEqC,aAAamD,OAAO,CAAC,gBAAgB5B,KAAK+B,SAAS,CAAC7F;QACpDuC,aAAamD,OAAO,CAAC,eAAe5B,KAAK+B,SAAS,CAAC5F;QACnDsC,aAAamD,OAAO,CAAC,oBAAoB5B,KAAK+B,SAAS,CAAC3F;IAC1D;IAEQyD,gBAA6B;QACnC,IAAI;YACF,MAAMmC,WAAWvD,aAAasB,OAAO,CAAC;YACtC,OAAOiC,WAAWhC,KAAKC,KAAK,CAAC+B,YAAY;QAC3C,EAAE,OAAM;YACN,OAAO;QACT;IACF;IAEQjF,cAAoB;QAC1B2C,iBAAO,CAACuC,MAAM,CAAC;QACfvC,iBAAO,CAACuC,MAAM,CAAC;QACfxD,aAAaC,UAAU,CAAC;IAC1B;IAEQL,gBAAsB;QAC5BI,aAAaC,UAAU,CAAC;QACxBD,aAAaC,UAAU,CAAC;QACxBD,aAAaC,UAAU,CAAC;IAC1B;IAEA,yEAAyE;IACzEwD,wBAA8B;QAC5B,IAAI,CAAC,IAAI,CAACvC,eAAe,MAAMwC,QAAQC,GAAG,CAACC,QAAQ,KAAK,UAAU,OAAOnE,WAAW,aAAa;YAC/F;QACF;QAEA,qDAAqD;QACrDoE,IAAAA,gCAAoB;QAEpB,uCAAuC;QACvC,MAAMC,mBAAmB,AAACrE,OAAeW,qBAAqB;QAC9D,IAAI0D,kBAAkB;YACpBvD,IAAAA,6BAAiB,EAACuD;YAClB,OAAO,AAACrE,OAAeW,qBAAqB;QAC9C;QAEA,kCAAkC;QAClC,MAAMD,kBAAkB4D,IAAAA,2BAAe,EAAC;YACtC,IAAI,CAAC,IAAI,CAAC7C,eAAe,IAAI;gBAC3BX,IAAAA,6BAAiB,EAACJ;gBAClB,IAAI,OAAOV,WAAW,aAAa;oBACjC,OAAO,AAACA,OAAeW,qBAAqB;gBAC9C;gBACA;YACF;YAEA,IAAI,IAAI,CAACgC,kBAAkB,IAAI;gBAC7B,IAAI,CAAClE,YAAY,GAAG8F,KAAK,CAAClH,CAAAA;oBACxBD,QAAQC,KAAK,CAAC,oCAAoCA;oBAElD,oEAAoE;oBACpE,IAAIA,OAAOM,UAAUW,WAAW,KAAK;wBACnClB,QAAQ0C,IAAI,CAAC;wBACb,IAAI,CAACjB,WAAW;wBAChB,IAAI,CAACsB,aAAa;wBAClBH,OAAOC,QAAQ,CAACC,IAAI,GAAG;oBACzB;gBACF;YACF;QACF,GAAG,OAAO,qBAAqB;SAG9BF,QAAeW,qBAAqB,GAAGD;IAC1C;IAMA8D,oBAA0B;QACxB,IAAI,CAACC,gBAAgB,GAAG3B,KAAKG,GAAG;IAClC;IAEAyB,sBAA+B;QAC7B,MAAMzB,MAAMH,KAAKG,GAAG;QACpB,MAAM0B,wBAAwB1B,MAAM,IAAI,CAACwB,gBAAgB;QACzD,OAAOE,wBAAwB,IAAI,CAACC,uBAAuB;IAC7D;IAEAC,6BAAmC;QACjC,gGAAgG;QAChG,wFAAwF;QACxFzH,QAAQM,GAAG,CAAC;QAEZ,mFAAmF;QACnF,IAAI,OAAOsC,WAAW,eAAeiE,QAAQC,GAAG,CAACC,QAAQ,KAAK,QAAQ;YACpE,IAAI,CAACK,iBAAiB;QACxB;QAEA;IACF;;aAlbQ9F,sBAA6D;aAC7DlB,eAAsD;aAC7C0F,wBAAwB,IAAI,KAAK,KAAK,4BAA4B;;aAC3EjG,qBAAkC,IAAI6H;QAsZ9C,qCAAqC;aAC7BF,0BAA0B,KAAK,KAAK,KAAK,aAAa;;aACtDH,mBAAmB3B,KAAKG,GAAG;;AAwBrC;AAEO,MAAMnG,cAAc,IAAID,cAE/B,mFAAmF"}