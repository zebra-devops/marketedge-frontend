bc3bfaaf8467045d3d03f7c7e31e2ce2
"use client";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    AuthContext: function() {
        return AuthContext;
    },
    useAuth: function() {
        return useAuth;
    },
    useAuthContext: function() {
        return useAuthContext;
    }
});
const _react = require("react");
const _auth = require("../services/auth");
const AuthContext = (0, _react.createContext)(undefined);
const useAuthContext = ()=>{
    const context = (0, _react.useContext)(AuthContext);
    if (!context) {
        throw new Error("useAuthContext must be used within an AuthProvider");
    }
    return context;
};
const useAuth = ()=>{
    const [state, setState] = (0, _react.useState)({
        user: null,
        tenant: null,
        permissions: [],
        isLoading: true,
        isAuthenticated: false,
        isInitialized: false
    });
    (0, _react.useEffect)(()=>{
        initializeAuth();
    }, []);
    const initializeAuth = async ()=>{
        try {
            setState((prev)=>({
                    ...prev,
                    isLoading: true
                }));
            // Check if user has valid authentication
            if (_auth.authService.isAuthenticated()) {
                try {
                    // Get current user data from backend
                    const userResponse = await _auth.authService.getCurrentUser();
                    const permissions = _auth.authService.getUserPermissions();
                    setState({
                        user: userResponse.user,
                        tenant: userResponse.tenant,
                        permissions,
                        isLoading: false,
                        isAuthenticated: true,
                        isInitialized: true
                    });
                } catch (error) {
                    console.error("Failed to get current user:", error);
                    // Clear invalid tokens
                    await _auth.authService.logout();
                    setState({
                        user: null,
                        tenant: null,
                        permissions: [],
                        isLoading: false,
                        isAuthenticated: false,
                        isInitialized: true
                    });
                }
            } else {
                setState({
                    user: null,
                    tenant: null,
                    permissions: [],
                    isLoading: false,
                    isAuthenticated: false,
                    isInitialized: true
                });
            }
        } catch (error) {
            console.error("Auth initialization failed:", error);
            setState({
                user: null,
                tenant: null,
                permissions: [],
                isLoading: false,
                isAuthenticated: false,
                isInitialized: true
            });
        }
    };
    const login = async (loginData)=>{
        setState((prev)=>({
                ...prev,
                isLoading: true
            }));
        try {
            const response = await _auth.authService.login(loginData);
            setState({
                user: response.user,
                tenant: response.tenant,
                permissions: response.permissions,
                isLoading: false,
                isAuthenticated: true,
                isInitialized: true
            });
            return response;
        } catch (error) {
            setState((prev)=>({
                    ...prev,
                    isLoading: false,
                    user: null,
                    tenant: null,
                    permissions: [],
                    isAuthenticated: false
                }));
            throw error;
        }
    };
    const logout = async (allDevices = false)=>{
        setState((prev)=>({
                ...prev,
                isLoading: true
            }));
        try {
            await _auth.authService.logout(allDevices);
        } catch (error) {
            console.warn("Logout error:", error);
        } finally{
            setState({
                user: null,
                tenant: null,
                permissions: [],
                isLoading: false,
                isAuthenticated: false,
                isInitialized: true
            });
        }
    };
    const refreshUser = async ()=>{
        try {
            const userResponse = await _auth.authService.getCurrentUser();
            const permissions = _auth.authService.getUserPermissions();
            setState((prev)=>({
                    ...prev,
                    user: userResponse.user,
                    tenant: userResponse.tenant,
                    permissions
                }));
        } catch (error) {
            console.error("Failed to refresh user data:", error);
            throw error;
        }
    };
    const hasPermission = (permission)=>{
        return _auth.authService.hasPermission(permission);
    };
    const hasAnyPermission = (permissions)=>{
        return _auth.authService.hasAnyPermission(permissions);
    };
    const hasRole = (role)=>{
        return _auth.authService.getUserRole() === role;
    };
    const checkSession = async ()=>{
        try {
            return await _auth.authService.checkSession();
        } catch (error) {
            console.error("Session check failed:", error);
            throw error;
        }
    };
    const extendSession = async ()=>{
        try {
            return await _auth.authService.extendSession();
        } catch (error) {
            console.error("Session extension failed:", error);
            throw error;
        }
    };
    const getTenantContext = ()=>{
        return state.tenant;
    };
    const validateTenantAccess = (requiredTenant)=>{
        if (!state.tenant || !state.isAuthenticated) {
            return false;
        }
        return state.tenant.id === requiredTenant;
    };
    return {
        ...state,
        login,
        logout,
        refreshUser,
        hasPermission,
        hasAnyPermission,
        hasRole,
        checkSession,
        extendSession,
        getTenantContext,
        validateTenantAccess
    };
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0L1NpdGVzL01hcmtldEVkZ2UvcGxhdGZvcm0td3JhcHBlci9mcm9udGVuZC9zcmMvaG9va3MvdXNlQXV0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXNlciB9IGZyb20gJ0AvdHlwZXMvYXV0aCdcbmltcG9ydCB7IGF1dGhTZXJ2aWNlIH0gZnJvbSAnQC9zZXJ2aWNlcy9hdXRoJ1xuXG5pbnRlcmZhY2UgRW5oYW5jZWRVc2VyIGV4dGVuZHMgVXNlciB7XG4gIGNyZWF0ZWRfYXQ/OiBzdHJpbmdcbiAgdXBkYXRlZF9hdD86IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgVGVuYW50SW5mbyB7XG4gIGlkOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIGluZHVzdHJ5OiBzdHJpbmdcbiAgc3Vic2NyaXB0aW9uX3BsYW46IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgQXV0aFN0YXRlIHtcbiAgdXNlcjogRW5oYW5jZWRVc2VyIHwgbnVsbFxuICB0ZW5hbnQ6IFRlbmFudEluZm8gfCBudWxsXG4gIHBlcm1pc3Npb25zOiBzdHJpbmdbXVxuICBpc0xvYWRpbmc6IGJvb2xlYW5cbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuXG4gIGlzSW5pdGlhbGl6ZWQ6IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIEF1dGhDb250ZXh0VHlwZSBleHRlbmRzIEF1dGhTdGF0ZSB7XG4gIGxvZ2luOiAobG9naW5EYXRhOiB7IGNvZGU6IHN0cmluZzsgcmVkaXJlY3RfdXJpOiBzdHJpbmc7IHN0YXRlPzogc3RyaW5nIH0pID0+IFByb21pc2U8YW55PlxuICBsb2dvdXQ6IChhbGxEZXZpY2VzPzogYm9vbGVhbikgPT4gUHJvbWlzZTx2b2lkPlxuICByZWZyZXNoVXNlcjogKCkgPT4gUHJvbWlzZTx2b2lkPlxuICBoYXNQZXJtaXNzaW9uOiAocGVybWlzc2lvbjogc3RyaW5nKSA9PiBib29sZWFuXG4gIGhhc0FueVBlcm1pc3Npb246IChwZXJtaXNzaW9uczogc3RyaW5nW10pID0+IGJvb2xlYW5cbiAgaGFzUm9sZTogKHJvbGU6IHN0cmluZykgPT4gYm9vbGVhblxuICBjaGVja1Nlc3Npb246ICgpID0+IFByb21pc2U8YW55PlxuICBleHRlbmRTZXNzaW9uOiAoKSA9PiBQcm9taXNlPGFueT5cbiAgZ2V0VGVuYW50Q29udGV4dDogKCkgPT4gVGVuYW50SW5mbyB8IG51bGxcbiAgdmFsaWRhdGVUZW5hbnRBY2Nlc3M6IChyZXF1aXJlZFRlbmFudDogc3RyaW5nKSA9PiBib29sZWFuXG59XG5cbmNvbnN0IEF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBdXRoQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZClcblxuZXhwb3J0IGNvbnN0IHVzZUF1dGhDb250ZXh0ID0gKCk6IEF1dGhDb250ZXh0VHlwZSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEF1dGhDb250ZXh0KVxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUF1dGhDb250ZXh0IG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gQXV0aFByb3ZpZGVyJylcbiAgfVxuICByZXR1cm4gY29udGV4dFxufVxuXG5leHBvcnQgY29uc3QgdXNlQXV0aCA9ICgpOiBBdXRoQ29udGV4dFR5cGUgPT4ge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPEF1dGhTdGF0ZT4oe1xuICAgIHVzZXI6IG51bGwsXG4gICAgdGVuYW50OiBudWxsLFxuICAgIHBlcm1pc3Npb25zOiBbXSxcbiAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgaXNBdXRoZW50aWNhdGVkOiBmYWxzZSxcbiAgICBpc0luaXRpYWxpemVkOiBmYWxzZVxuICB9KVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaW5pdGlhbGl6ZUF1dGgoKVxuICB9LCBbXSlcblxuICBjb25zdCBpbml0aWFsaXplQXV0aCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgc2V0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBpc0xvYWRpbmc6IHRydWUgfSkpXG5cbiAgICAgIC8vIENoZWNrIGlmIHVzZXIgaGFzIHZhbGlkIGF1dGhlbnRpY2F0aW9uXG4gICAgICBpZiAoYXV0aFNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBHZXQgY3VycmVudCB1c2VyIGRhdGEgZnJvbSBiYWNrZW5kXG4gICAgICAgICAgY29uc3QgdXNlclJlc3BvbnNlID0gYXdhaXQgYXV0aFNlcnZpY2UuZ2V0Q3VycmVudFVzZXIoKVxuICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gYXV0aFNlcnZpY2UuZ2V0VXNlclBlcm1pc3Npb25zKClcbiAgICAgICAgICBcbiAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICB1c2VyOiB1c2VyUmVzcG9uc2UudXNlcixcbiAgICAgICAgICAgIHRlbmFudDogdXNlclJlc3BvbnNlLnRlbmFudCxcbiAgICAgICAgICAgIHBlcm1pc3Npb25zLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzQXV0aGVudGljYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlzSW5pdGlhbGl6ZWQ6IHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgY3VycmVudCB1c2VyOicsIGVycm9yKVxuICAgICAgICAgIC8vIENsZWFyIGludmFsaWQgdG9rZW5zXG4gICAgICAgICAgYXdhaXQgYXV0aFNlcnZpY2UubG9nb3V0KClcbiAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICB1c2VyOiBudWxsLFxuICAgICAgICAgICAgdGVuYW50OiBudWxsLFxuICAgICAgICAgICAgcGVybWlzc2lvbnM6IFtdLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzQXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgICAgICAgICBpc0luaXRpYWxpemVkOiB0cnVlXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIHVzZXI6IG51bGwsXG4gICAgICAgICAgdGVuYW50OiBudWxsLFxuICAgICAgICAgIHBlcm1pc3Npb25zOiBbXSxcbiAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgIGlzQXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgICAgICAgaXNJbml0aWFsaXplZDogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBdXRoIGluaXRpYWxpemF0aW9uIGZhaWxlZDonLCBlcnJvcilcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgdGVuYW50OiBudWxsLFxuICAgICAgICBwZXJtaXNzaW9uczogW10sXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGlzQXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgICAgIGlzSW5pdGlhbGl6ZWQ6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbG9naW4gPSBhc3luYyAobG9naW5EYXRhOiB7IGNvZGU6IHN0cmluZzsgcmVkaXJlY3RfdXJpOiBzdHJpbmc7IHN0YXRlPzogc3RyaW5nIH0pID0+IHtcbiAgICBzZXRTdGF0ZShwcmV2ID0+ICh7IC4uLnByZXYsIGlzTG9hZGluZzogdHJ1ZSB9KSlcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoU2VydmljZS5sb2dpbihsb2dpbkRhdGEpXG4gICAgICBcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgdXNlcjogcmVzcG9uc2UudXNlcixcbiAgICAgICAgdGVuYW50OiByZXNwb25zZS50ZW5hbnQsXG4gICAgICAgIHBlcm1pc3Npb25zOiByZXNwb25zZS5wZXJtaXNzaW9ucyxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgaXNBdXRoZW50aWNhdGVkOiB0cnVlLFxuICAgICAgICBpc0luaXRpYWxpemVkOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICB1c2VyOiBudWxsLFxuICAgICAgICB0ZW5hbnQ6IG51bGwsXG4gICAgICAgIHBlcm1pc3Npb25zOiBbXSxcbiAgICAgICAgaXNBdXRoZW50aWNhdGVkOiBmYWxzZVxuICAgICAgfSkpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGxvZ291dCA9IGFzeW5jIChhbGxEZXZpY2VzOiBib29sZWFuID0gZmFsc2UpID0+IHtcbiAgICBzZXRTdGF0ZShwcmV2ID0+ICh7IC4uLnByZXYsIGlzTG9hZGluZzogdHJ1ZSB9KSlcbiAgICBcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYXV0aFNlcnZpY2UubG9nb3V0KGFsbERldmljZXMpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignTG9nb3V0IGVycm9yOicsIGVycm9yKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIHVzZXI6IG51bGwsXG4gICAgICAgIHRlbmFudDogbnVsbCxcbiAgICAgICAgcGVybWlzc2lvbnM6IFtdLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgICAgICBpc0luaXRpYWxpemVkOiB0cnVlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlZnJlc2hVc2VyID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyUmVzcG9uc2UgPSBhd2FpdCBhdXRoU2VydmljZS5nZXRDdXJyZW50VXNlcigpXG4gICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IGF1dGhTZXJ2aWNlLmdldFVzZXJQZXJtaXNzaW9ucygpXG4gICAgICBcbiAgICAgIHNldFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgdXNlcjogdXNlclJlc3BvbnNlLnVzZXIsXG4gICAgICAgIHRlbmFudDogdXNlclJlc3BvbnNlLnRlbmFudCxcbiAgICAgICAgcGVybWlzc2lvbnNcbiAgICAgIH0pKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVmcmVzaCB1c2VyIGRhdGE6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGhhc1Blcm1pc3Npb24gPSAocGVybWlzc2lvbjogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuIGF1dGhTZXJ2aWNlLmhhc1Blcm1pc3Npb24ocGVybWlzc2lvbilcbiAgfVxuXG4gIGNvbnN0IGhhc0FueVBlcm1pc3Npb24gPSAocGVybWlzc2lvbnM6IHN0cmluZ1tdKTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuIGF1dGhTZXJ2aWNlLmhhc0FueVBlcm1pc3Npb24ocGVybWlzc2lvbnMpXG4gIH1cblxuICBjb25zdCBoYXNSb2xlID0gKHJvbGU6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBhdXRoU2VydmljZS5nZXRVc2VyUm9sZSgpID09PSByb2xlXG4gIH1cblxuICBjb25zdCBjaGVja1Nlc3Npb24gPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBhdXRoU2VydmljZS5jaGVja1Nlc3Npb24oKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTZXNzaW9uIGNoZWNrIGZhaWxlZDonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZXh0ZW5kU2Vzc2lvbiA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGF1dGhTZXJ2aWNlLmV4dGVuZFNlc3Npb24oKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTZXNzaW9uIGV4dGVuc2lvbiBmYWlsZWQ6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGdldFRlbmFudENvbnRleHQgPSAoKTogVGVuYW50SW5mbyB8IG51bGwgPT4ge1xuICAgIHJldHVybiBzdGF0ZS50ZW5hbnRcbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRlVGVuYW50QWNjZXNzID0gKHJlcXVpcmVkVGVuYW50OiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICBpZiAoIXN0YXRlLnRlbmFudCB8fCAhc3RhdGUuaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLnRlbmFudC5pZCA9PT0gcmVxdWlyZWRUZW5hbnRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgbG9naW4sXG4gICAgbG9nb3V0LFxuICAgIHJlZnJlc2hVc2VyLFxuICAgIGhhc1Blcm1pc3Npb24sXG4gICAgaGFzQW55UGVybWlzc2lvbixcbiAgICBoYXNSb2xlLFxuICAgIGNoZWNrU2Vzc2lvbixcbiAgICBleHRlbmRTZXNzaW9uLFxuICAgIGdldFRlbmFudENvbnRleHQsXG4gICAgdmFsaWRhdGVUZW5hbnRBY2Nlc3NcbiAgfVxufVxuXG5leHBvcnQgeyBBdXRoQ29udGV4dCB9Il0sIm5hbWVzIjpbIkF1dGhDb250ZXh0IiwidXNlQXV0aCIsInVzZUF1dGhDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVuZGVmaW5lZCIsImNvbnRleHQiLCJ1c2VDb250ZXh0IiwiRXJyb3IiLCJzdGF0ZSIsInNldFN0YXRlIiwidXNlU3RhdGUiLCJ1c2VyIiwidGVuYW50IiwicGVybWlzc2lvbnMiLCJpc0xvYWRpbmciLCJpc0F1dGhlbnRpY2F0ZWQiLCJpc0luaXRpYWxpemVkIiwidXNlRWZmZWN0IiwiaW5pdGlhbGl6ZUF1dGgiLCJwcmV2IiwiYXV0aFNlcnZpY2UiLCJ1c2VyUmVzcG9uc2UiLCJnZXRDdXJyZW50VXNlciIsImdldFVzZXJQZXJtaXNzaW9ucyIsImVycm9yIiwiY29uc29sZSIsImxvZ291dCIsImxvZ2luIiwibG9naW5EYXRhIiwicmVzcG9uc2UiLCJhbGxEZXZpY2VzIiwid2FybiIsInJlZnJlc2hVc2VyIiwiaGFzUGVybWlzc2lvbiIsInBlcm1pc3Npb24iLCJoYXNBbnlQZXJtaXNzaW9uIiwiaGFzUm9sZSIsInJvbGUiLCJnZXRVc2VyUm9sZSIsImNoZWNrU2Vzc2lvbiIsImV4dGVuZFNlc3Npb24iLCJnZXRUZW5hbnRDb250ZXh0IiwidmFsaWRhdGVUZW5hbnRBY2Nlc3MiLCJyZXF1aXJlZFRlbmFudCIsImlkIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O0lBZ1BTQSxXQUFXO2VBQVhBOztJQTlMSUMsT0FBTztlQUFQQTs7SUFSQUMsY0FBYztlQUFkQTs7O3VCQXhDa0Q7c0JBRW5DO0FBb0M1QixNQUFNRixjQUFjRyxJQUFBQSxvQkFBYSxFQUE4QkM7QUFFeEQsTUFBTUYsaUJBQWlCO0lBQzVCLE1BQU1HLFVBQVVDLElBQUFBLGlCQUFVLEVBQUNOO0lBQzNCLElBQUksQ0FBQ0ssU0FBUztRQUNaLE1BQU0sSUFBSUUsTUFBTTtJQUNsQjtJQUNBLE9BQU9GO0FBQ1Q7QUFFTyxNQUFNSixVQUFVO0lBQ3JCLE1BQU0sQ0FBQ08sT0FBT0Ms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