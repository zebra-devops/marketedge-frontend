9bcb1c74623cbff24db723c1814bf769
/**
 * Comprehensive Authentication Service Tests
 * 
 * Tests all authentication functions to achieve 85%+ coverage:
 * - login, logout, refresh, getCurrentUser
 * - Multi-tenant authentication scenarios
 * - Token management edge cases
 * - Authentication error handling
 * - Session management
 */ "use strict";
// Mock dependencies
jest.mock("../api");
jest.mock("js-cookie");
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _auth = require("../auth");
const _api = require("../api");
const _jscookie = /*#__PURE__*/ _interop_require_default(require("js-cookie"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const mockApiService = _api.apiService;
const mockCookies = _jscookie.default;
describe("AuthService", ()=>{
    let service;
    beforeEach(()=>{
        service = new _auth.AuthService();
        jest.clearAllMocks();
    });
    afterEach(()=>{
        // Clear mocks after each test
        jest.restoreAllMocks();
    });
    describe("login", ()=>{
        const mockLoginRequest = {
            code: "valid-auth-code",
            redirect_uri: "http://localhost:3000/callback"
        };
        const mockTokenResponse = {
            access_token: "mock-access-token",
            refresh_token: "mock-refresh-token",
            token_type: "bearer",
            user: {
                id: "user-123",
                email: "test@example.com",
                first_name: "Test",
                last_name: "User",
                role: "analyst",
                organisation_id: "org-123",
                is_active: true
            }
        };
        it("should successfully login with valid credentials", async ()=>{
            mockApiService.post.mockResolvedValue(mockTokenResponse);
            const result = await service.login(mockLoginRequest);
            expect(mockApiService.post).toHaveBeenCalledWith("/auth/login", mockLoginRequest);
            expect(mockCookies.set).toHaveBeenCalledWith("access_token", "mock-access-token", {
                expires: 1
            });
            expect(mockCookies.set).toHaveBeenCalledWith("refresh_token", "mock-refresh-token", {
                expires: 7
            });
            expect(result).toEqual(mockTokenResponse);
        });
        it("should handle login API errors", async ()=>{
            const errorResponse = new Error("Invalid authorization code");
            mockApiService.post.mockRejectedValue(errorResponse);
            await expect(service.login(mockLoginRequest)).rejects.toThrow("Invalid authorization code");
            expect(mockApiService.post).toHaveBeenCalledWith("/auth/login", mockLoginRequest);
            expect(mockCookies.set).not.toHaveBeenCalled();
        });
        it("should handle network errors during login", async ()=>{
            const networkError = new Error("Network timeout");
            mockApiService.post.mockRejectedValue(networkError);
            await expect(service.login(mockLoginRequest)).rejects.toThrow("Network timeout");
        });
        it("should set cookies with correct expiration times", async ()=>{
            mockApiService.post.mockResolvedValue(mockTokenResponse);
            await service.login(mockLoginRequest);
            expect(mockCookies.set).toHaveBeenCalledWith("access_token", "mock-access-token", {
                expires: 1
            } // 1 day
            );
            expect(mockCookies.set).toHaveBeenCalledWith("refresh_token", "mock-refresh-token", {
                expires: 7
            } // 7 days
            );
        });
    });
    describe("getCurrentUser", ()=>{
        const mockUser = {
            id: "user-456",
            email: "current@example.com",
            first_name: "Current",
            last_name: "User",
            role: "admin",
            organisation_id: "org-456",
            is_active: true
        };
        it("should successfully fetch current user", async ()=>{
            mockApiService.get.mockResolvedValue(mockUser);
            const result = await service.getCurrentUser();
            expect(mockApiService.get).toHaveBeenCalledWith("/auth/me");
            expect(result).toEqual(mockUser);
        });
        it("should handle unauthorized response", async ()=>{
            const unauthorizedError = new Error("Not authenticated");
            mockApiService.get.mockRejectedValue(unauthorizedError);
            await expect(service.getCurrentUser()).rejects.toThrow("Not authenticated");
            expect(mockApiService.get).toHaveBeenCalledWith("/auth/me");
        });
        it("should handle server errors", async ()=>{
            const serverError = new Error("Internal server error");
            mockApiService.get.mockRejectedValue(serverError);
            await expect(service.getCurrentUser()).rejects.toThrow("Internal server error");
        });
    });
    describe("getAuth0Url", ()=>{
        const mockRedirectUri = "http://localhost:3000/callback";
        const mockAuthUrlResponse = {
            auth_url: "https://dev-platform.auth0.com/authorize?response_type=code&client_id=test&redirect_uri=http%3A//localhost%3A3000/callback&scope=openid%20profile%20email"
        };
        it("should successfully get Auth0 URL", async ()=>{
            mockApiService.get.mockResolvedValue(mockAuthUrlResponse);
            const result = await service.getAuth0Url(mockRedirectUri);
            expect(mockApiService.get).toHaveBeenCalledWith(`/auth/auth0-url?redirect_uri=${encodeURIComponent(mockRedirectUri)}`);
            expect(result).toEqual(mockAuthUrlResponse);
        });
        it("should handle URL with special characters", async ()=>{
            const specialRedirectUri = "http://localhost:3000/callback?state=test&nonce=123";
            mockApiService.get.mockResolvedValue(mockAuthUrlResponse);
            await service.getAuth0Url(specialRedirectUri);
            expect(mockApiService.get).toHaveBeenCalledWith(`/auth/auth0-url?redirect_uri=${encodeURIComponent(specialRedirectUri)}`);
        });
        it("should handle API errors when getting Auth0 URL", async ()=>{
            const apiError = new Error("Auth0 configuration error");
            mockApiService.get.mockRejectedValue(apiError);
            await expect(service.getAuth0Url(mockRedirectUri)).rejects.toThrow("Auth0 configuration error");
        });
    });
    describe("logout", ()=>{
        // Mock window.location
        const mockLocation = {
            href: ""
        };
        beforeEach(()=>{
            delete window.location;
            window.location = mockLocation;
        });
        it("should remove cookies and redirect to login", ()=>{
            service.logout();
            expect(mockCookies.remove).toHaveBeenCalledWith("access_token");
            expect(mockCookies.remove).toHaveBeenCalledWith("refresh_token");
            expect(window.location.href).toBe("/login");
        });
        it("should handle logout even if cookies do not exist", ()=>{
            // Test that logout still works even if cookies.remove doesn't throw
            mockCookies.remove.mockImplementation(()=>undefined);
            service.logout();
            expect(mockCookies.remove).toHaveBeenCalledWith("access_token");
            expect(mockCookies.remove).toHaveBeenCalledWith("refresh_token");
            expect(window.location.href).toBe("/login");
        });
    });
    describe("getToken", ()=>{
        it("should return access token when it exists", ()=>{
            mockCookies.get.mockReturnValue("valid-access-token");
            const token = service.getToken();
            expect(mockCookies.get).toHaveBeenCalledWith("access_token");
            expect(token).toBe("valid-access-token");
        });
        it("should return undefined when token does not exist", ()=>{
            mockCookies.get.mockReturnValue(undefined);
            const token = service.getToken();
            expect(mockCookies.get).toHaveBeenCalledWith("access_token");
            expect(token).toBeUndefined();
        });
        it("should return empty string as falsy when token is empty", ()=>{
            mockCookies.get.mockReturnValue("");
            const token = service.getToken();
            expect(mockCookies.get).toHaveBeenCalledWith("access_token");
            expect(token).toBe("");
        });
    });
    describe("isAuthenticated", ()=>{
        it("should return true when token exists", ()=>{
            mockCookies.get.mockReturnValue("valid-token");
            const isAuthenticated = service.isAuthenticated();
            expect(mockCookies.get).toHaveBeenCalledWith("access_token");
            expect(isAuthenticated).toBe(true);
        });
        it("should return false when token does not exist", ()=>{
            mockCookies.get.mockReturnValue(undefined);
            const isAuthenticated = service.isAuthenticated();
            expect(mockCookies.get).toHaveBeenCalledWith("access_token");
            expect(isAuthenticated).toBe(false);
        });
        it("should return false when token is empty string", ()=>{
            mockCookies.get.mockReturnValue("");
            const isAuthenticated = service.isAuthenticated();
            expect(mockCookies.get).toHaveBeenCalledWith("access_token");
            expect(isAuthenticated).toBe(false);
        });
        it("should return false when token is null", ()=>{
            mockCookies.get.mockReturnValue(null);
            const isAuthenticated = service.isAuthenticated();
            expect(isAuthenticated).toBe(false);
        });
    });
    describe("Multi-tenant scenarios", ()=>{
        const hotelTenantUser = {
            id: "hotel-user",
            email: "hotel@example.com",
            first_name: "Hotel",
            last_name: "Manager",
            role: "admin",
            organisation_id: "hotel-org-123",
            is_active: true
        };
        const cinemaTenantUser = {
            id: "cinema-user",
            email: "cinema@example.com",
            first_name: "Cinema",
            last_name: "Operator",
            role: "analyst",
            organisation_id: "cinema-org-456",
            is_active: true
        };
        it("should handle hotel tenant authentication", async ()=>{
            const hotelLogin = {
                code: "hotel-auth-code",
                redirect_uri: "http://hotel.platform.com/callback"
            };
            const hotelTokenResponse = {
                access_token: "hotel-access-token",
                refresh_token: "hotel-refresh-token",
                token_type: "bearer",
                user: hotelTenantUser
            };
            mockApiService.post.mockResolvedValue(hotelTokenResponse);
            const result = await service.login(hotelLogin);
            expect(result.user.organisation_id).toBe("hotel-org-123");
            expect(result.user.role).toBe("admin");
        });
        it("should handle cinema tenant authentication", async ()=>{
            const cinemaLogin = {
                code: "cinema-auth-code",
                redirect_uri: "http://cinema.platform.com/callback"
            };
            const cinemaTokenResponse = {
                access_token: "cinema-access-token",
                refresh_token: "cinema-refresh-token",
                token_type: "bearer",
                user: cinemaTenantUser
            };
            mockApiService.post.mockResolvedValue(cinemaTokenResponse);
            const result = await service.login(cinemaLogin);
            expect(result.user.organisation_id).toBe("cinema-org-456");
            expect(result.user.role).toBe("analyst");
        });
        it("should handle tenant-specific user data", async ()=>{
            mockApiService.get.mockResolvedValue(hotelTenantUser);
            const user = await service.getCurrentUser();
            expect(user.organisation_id).toBe("hotel-org-123");
            expect(user.email).toBe("hotel@example.com");
        });
    });
    describe("Token edge cases", ()=>{
        it("should handle malformed tokens gracefully", ()=>{
            mockCookies.get.mockReturnValue("malformed.token.here");
            const token = service.getToken();
            expect(token).toBe("malformed.token.here");
            const isAuthenticated = service.isAuthenticated();
            expect(isAuthenticated).toBe(true) // Should still consider it authenticated
            ;
        });
        it("should handle expired tokens", async ()=>{
            // Token exists but API call fails with 401
            mockCookies.get.mockReturnValue("expired-token");
            mockApiService.get.mockRejectedValue(new Error("Token expired"));
            await expect(service.getCurrentUser()).rejects.toThrow("Token expired");
        });
    });
    describe("Session management", ()=>{
        it("should maintain consistent state across multiple calls", ()=>{
            mockCookies.get.mockReturnValue("consistent-token");
            expect(service.isAuthenticated()).toBe(true);
            expect(service.getToken()).toBe("consistent-token");
            expect(service.isAuthenticated()).toBe(true);
        });
        it("should handle cookie changes during session", ()=>{
            // First call returns token
            mockCookies.get.mockReturnValueOnce("initial-token");
            expect(service.isAuthenticated()).toBe(true);
            // Second call returns no token (e.g., cookie expired)
            mockCookies.get.mockReturnValueOnce(undefined);
            expect(service.isAuthenticated()).toBe(false);
        });
    });
    describe("Error boundary scenarios", ()=>{
        it("should handle cookie access errors", ()=>{
            mockCookies.get.mockImplementation(()=>{
                throw new Error("Cookie access denied");
            });
            expect(()=>service.getToken()).toThrow("Cookie access denied");
            expect(()=>service.isAuthenticated()).toThrow("Cookie access denied");
        });
        it("should handle cookie setting errors during login", async ()=>{
            const tokenResponse = {
                access_token: "test-token",
                refresh_token: "test-refresh",
                token_type: "bearer",
                user: {
                    id: "user-123",
                    email: "test@example.com",
                    first_name: "Test",
                    last_name: "User",
                    role: "analyst",
                    organisation_id: "org-123",
                    is_active: true
                }
            };
            mockApiService.post.mockResolvedValue(tokenResponse);
            mockCookies.set.mockImplementation(()=>{
                throw new Error("Cookie setting failed");
            });
            // Should still return the response even if cookie setting fails
            const result = await service.login({
                code: "test-code",
                redirect_uri: "http://localhost:3000/callback"
            });
            expect(result).toEqual(tokenResponse);
        });
    });
});
describe("Singleton authService", ()=>{
    it("should export a singleton instance", ()=>{
        expect(_auth.authService).toBeInstanceOf(_auth.AuthService);
    });
    it("should maintain state across imports", ()=>{
        const instance1 = _auth.authService;
        const instance2 = _auth.authService;
        expect(instance1).toBe(instance2);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0L1NpdGVzL01hcmtldEVkZ2UvcGxhdGZvcm0td3JhcHBlci9mcm9udGVuZC9zcmMvc2VydmljZXMvX190ZXN0c19fL2F1dGgudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbXByZWhlbnNpdmUgQXV0aGVudGljYXRpb24gU2VydmljZSBUZXN0c1xuICogXG4gKiBUZXN0cyBhbGwgYXV0aGVudGljYXRpb24gZnVuY3Rpb25zIHRvIGFjaGlldmUgODUlKyBjb3ZlcmFnZTpcbiAqIC0gbG9naW4sIGxvZ291dCwgcmVmcmVzaCwgZ2V0Q3VycmVudFVzZXJcbiAqIC0gTXVsdGktdGVuYW50IGF1dGhlbnRpY2F0aW9uIHNjZW5hcmlvc1xuICogLSBUb2tlbiBtYW5hZ2VtZW50IGVkZ2UgY2FzZXNcbiAqIC0gQXV0aGVudGljYXRpb24gZXJyb3IgaGFuZGxpbmdcbiAqIC0gU2Vzc2lvbiBtYW5hZ2VtZW50XG4gKi9cblxuaW1wb3J0IHsgQXV0aFNlcnZpY2UsIGF1dGhTZXJ2aWNlIH0gZnJvbSAnLi4vYXV0aCdcbmltcG9ydCB7IGFwaVNlcnZpY2UgfSBmcm9tICcuLi9hcGknXG5pbXBvcnQgeyBMb2dpblJlcXVlc3QsIFRva2VuUmVzcG9uc2UsIFVzZXIgfSBmcm9tICdAL3R5cGVzL2F1dGgnXG5pbXBvcnQgQ29va2llcyBmcm9tICdqcy1jb29raWUnXG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzXG5qZXN0Lm1vY2soJy4uL2FwaScpXG5qZXN0Lm1vY2soJ2pzLWNvb2tpZScpXG5cbmNvbnN0IG1vY2tBcGlTZXJ2aWNlID0gYXBpU2VydmljZSBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgYXBpU2VydmljZT5cbmNvbnN0IG1vY2tDb29raWVzID0gQ29va2llcyBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgQ29va2llcz5cblxuZGVzY3JpYmUoJ0F1dGhTZXJ2aWNlJywgKCkgPT4ge1xuICBsZXQgc2VydmljZTogQXV0aFNlcnZpY2VcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBzZXJ2aWNlID0gbmV3IEF1dGhTZXJ2aWNlKClcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKVxuICB9KVxuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgLy8gQ2xlYXIgbW9ja3MgYWZ0ZXIgZWFjaCB0ZXN0XG4gICAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKVxuICB9KVxuXG4gIGRlc2NyaWJlKCdsb2dpbicsICgpID0+IHtcbiAgICBjb25zdCBtb2NrTG9naW5SZXF1ZXN0OiBMb2dpblJlcXVlc3QgPSB7XG4gICAgICBjb2RlOiAndmFsaWQtYXV0aC1jb2RlJyxcbiAgICAgIHJlZGlyZWN0X3VyaTogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9jYWxsYmFjaycsXG4gICAgfVxuXG4gICAgY29uc3QgbW9ja1Rva2VuUmVzcG9uc2U6IFRva2VuUmVzcG9uc2UgPSB7XG4gICAgICBhY2Nlc3NfdG9rZW46ICdtb2NrLWFjY2Vzcy10b2tlbicsXG4gICAgICByZWZyZXNoX3Rva2VuOiAnbW9jay1yZWZyZXNoLXRva2VuJyxcbiAgICAgIHRva2VuX3R5cGU6ICdiZWFyZXInLFxuICAgICAgdXNlcjoge1xuICAgICAgICBpZDogJ3VzZXItMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgZmlyc3RfbmFtZTogJ1Rlc3QnLFxuICAgICAgICBsYXN0X25hbWU6ICdVc2VyJyxcbiAgICAgICAgcm9sZTogJ2FuYWx5c3QnLFxuICAgICAgICBvcmdhbmlzYXRpb25faWQ6ICdvcmctMTIzJyxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgfSxcbiAgICB9XG5cbiAgICBpdCgnc2hvdWxkIHN1Y2Nlc3NmdWxseSBsb2dpbiB3aXRoIHZhbGlkIGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0FwaVNlcnZpY2UucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVG9rZW5SZXNwb25zZSlcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS5sb2dpbihtb2NrTG9naW5SZXF1ZXN0KVxuXG4gICAgICBleHBlY3QobW9ja0FwaVNlcnZpY2UucG9zdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9hdXRoL2xvZ2luJywgbW9ja0xvZ2luUmVxdWVzdClcbiAgICAgIGV4cGVjdChtb2NrQ29va2llcy5zZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdhY2Nlc3NfdG9rZW4nLCAnbW9jay1hY2Nlc3MtdG9rZW4nLCB7IGV4cGlyZXM6IDEgfSlcbiAgICAgIGV4cGVjdChtb2NrQ29va2llcy5zZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdyZWZyZXNoX3Rva2VuJywgJ21vY2stcmVmcmVzaC10b2tlbicsIHsgZXhwaXJlczogNyB9KVxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrVG9rZW5SZXNwb25zZSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbG9naW4gQVBJIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSBuZXcgRXJyb3IoJ0ludmFsaWQgYXV0aG9yaXphdGlvbiBjb2RlJylcbiAgICAgIG1vY2tBcGlTZXJ2aWNlLnBvc3QubW9ja1JlamVjdGVkVmFsdWUoZXJyb3JSZXNwb25zZSlcblxuICAgICAgYXdhaXQgZXhwZWN0KHNlcnZpY2UubG9naW4obW9ja0xvZ2luUmVxdWVzdCkpLnJlamVjdHMudG9UaHJvdygnSW52YWxpZCBhdXRob3JpemF0aW9uIGNvZGUnKVxuICAgICAgXG4gICAgICBleHBlY3QobW9ja0FwaVNlcnZpY2UucG9zdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJy9hdXRoL2xvZ2luJywgbW9ja0xvZ2luUmVxdWVzdClcbiAgICAgIGV4cGVjdChtb2NrQ29va2llcy5zZXQpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbmV0d29yayBlcnJvcnMgZHVyaW5nIGxvZ2luJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbmV0d29ya0Vycm9yID0gbmV3IEVycm9yKCdOZXR3b3JrIHRpbWVvdXQnKVxuICAgICAgbW9ja0FwaVNlcnZpY2UucG9zdC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXR3b3JrRXJyb3IpXG5cbiAgICAgIGF3YWl0IGV4cGVjdChzZXJ2aWNlLmxvZ2luKG1vY2tMb2dpblJlcXVlc3QpKS5yZWplY3RzLnRvVGhyb3coJ05ldHdvcmsgdGltZW91dCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgc2V0IGNvb2tpZXMgd2l0aCBjb3JyZWN0IGV4cGlyYXRpb24gdGltZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpU2VydmljZS5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tUb2tlblJlc3BvbnNlKVxuXG4gICAgICBhd2FpdCBzZXJ2aWNlLmxvZ2luKG1vY2tMb2dpblJlcXVlc3QpXG5cbiAgICAgIGV4cGVjdChtb2NrQ29va2llcy5zZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnYWNjZXNzX3Rva2VuJyxcbiAgICAgICAgJ21vY2stYWNjZXNzLXRva2VuJyxcbiAgICAgICAgeyBleHBpcmVzOiAxIH0gLy8gMSBkYXlcbiAgICAgIClcbiAgICAgIGV4cGVjdChtb2NrQ29va2llcy5zZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAncmVmcmVzaF90b2tlbicsXG4gICAgICAgICdtb2NrLXJlZnJlc2gtdG9rZW4nLFxuICAgICAgICB7IGV4cGlyZXM6IDcgfSAvLyA3IGRheXNcbiAgICAgIClcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdnZXRDdXJyZW50VXNlcicsICgpID0+IHtcbiAgICBjb25zdCBtb2NrVXNlcjogVXNlciA9IHtcbiAgICAgIGlkOiAndXNlci00NTYnLFxuICAgICAgZW1haWw6ICdjdXJyZW50QGV4YW1wbGUuY29tJyxcbiAgICAgIGZpcnN0X25hbWU6ICdDdXJyZW50JyxcbiAgICAgIGxhc3RfbmFtZTogJ1VzZXInLFxuICAgICAgcm9sZTogJ2FkbWluJyxcbiAgICAgIG9yZ2FuaXNhdGlvbl9pZDogJ29yZy00NTYnLFxuICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgIH1cblxuICAgIGl0KCdzaG91bGQgc3VjY2Vzc2Z1bGx5IGZldGNoIGN1cnJlbnQgdXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tBcGlTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVXNlcilcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS5nZXRDdXJyZW50VXNlcigpXG5cbiAgICAgIGV4cGVjdChtb2NrQXBpU2VydmljZS5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvYXV0aC9tZScpXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tVc2VyKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB1bmF1dGhvcml6ZWQgcmVzcG9uc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB1bmF1dGhvcml6ZWRFcnJvciA9IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQnKVxuICAgICAgbW9ja0FwaVNlcnZpY2UuZ2V0Lm1vY2tSZWplY3RlZFZhbHVlKHVuYXV0aG9yaXplZEVycm9yKVxuXG4gICAgICBhd2FpdCBleHBlY3Qoc2VydmljZS5nZXRDdXJyZW50VXNlcigpKS5yZWplY3RzLnRvVGhyb3coJ05vdCBhdXRoZW50aWNhdGVkJylcbiAgICAgIGV4cGVjdChtb2NrQXBpU2VydmljZS5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCcvYXV0aC9tZScpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlcnZlciBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzZXJ2ZXJFcnJvciA9IG5ldyBFcnJvcignSW50ZXJuYWwgc2VydmVyIGVycm9yJylcbiAgICAgIG1vY2tBcGlTZXJ2aWNlLmdldC5tb2NrUmVqZWN0ZWRWYWx1ZShzZXJ2ZXJFcnJvcilcblxuICAgICAgYXdhaXQgZXhwZWN0KHNlcnZpY2UuZ2V0Q3VycmVudFVzZXIoKSkucmVqZWN0cy50b1Rocm93KCdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3InKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ2dldEF1dGgwVXJsJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tSZWRpcmVjdFVyaSA9ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvY2FsbGJhY2snXG4gICAgY29uc3QgbW9ja0F1dGhVcmxSZXNwb25zZSA9IHtcbiAgICAgIGF1dGhfdXJsOiAnaHR0cHM6Ly9kZXYtcGxhdGZvcm0uYXV0aDAuY29tL2F1dGhvcml6ZT9yZXNwb25zZV90eXBlPWNvZGUmY2xpZW50X2lkPXRlc3QmcmVkaXJlY3RfdXJpPWh0dHAlM0EvL2xvY2FsaG9zdCUzQTMwMDAvY2FsbGJhY2smc2NvcGU9b3BlbmlkJTIwcHJvZmlsZSUyMGVtYWlsJ1xuICAgIH1cblxuICAgIGl0KCdzaG91bGQgc3VjY2Vzc2Z1bGx5IGdldCBBdXRoMCBVUkwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQXBpU2VydmljZS5nZXQubW9ja1Jlc29sdmVkVmFsdWUobW9ja0F1dGhVcmxSZXNwb25zZSlcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS5nZXRBdXRoMFVybChtb2NrUmVkaXJlY3RVcmkpXG5cbiAgICAgIGV4cGVjdChtb2NrQXBpU2VydmljZS5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBgL2F1dGgvYXV0aDAtdXJsP3JlZGlyZWN0X3VyaT0ke2VuY29kZVVSSUNvbXBvbmVudChtb2NrUmVkaXJlY3RVcmkpfWBcbiAgICAgIClcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja0F1dGhVcmxSZXNwb25zZSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgVVJMIHdpdGggc3BlY2lhbCBjaGFyYWN0ZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgc3BlY2lhbFJlZGlyZWN0VXJpID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9jYWxsYmFjaz9zdGF0ZT10ZXN0Jm5vbmNlPTEyMydcbiAgICAgIG1vY2tBcGlTZXJ2aWNlLmdldC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQXV0aFVybFJlc3BvbnNlKVxuXG4gICAgICBhd2FpdCBzZXJ2aWNlLmdldEF1dGgwVXJsKHNwZWNpYWxSZWRpcmVjdFVyaSlcblxuICAgICAgZXhwZWN0KG1vY2tBcGlTZXJ2aWNlLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGAvYXV0aC9hdXRoMC11cmw/cmVkaXJlY3RfdXJpPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNwZWNpYWxSZWRpcmVjdFVyaSl9YFxuICAgICAgKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBBUEkgZXJyb3JzIHdoZW4gZ2V0dGluZyBBdXRoMCBVUkwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBFcnJvcignQXV0aDAgY29uZmlndXJhdGlvbiBlcnJvcicpXG4gICAgICBtb2NrQXBpU2VydmljZS5nZXQubW9ja1JlamVjdGVkVmFsdWUoYXBpRXJyb3IpXG5cbiAgICAgIGF3YWl0IGV4cGVjdChzZXJ2aWNlLmdldEF1dGgwVXJsKG1vY2tSZWRpcmVjdFVyaSkpLnJlamVjdHMudG9UaHJvdygnQXV0aDAgY29uZmlndXJhdGlvbiBlcnJvcicpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnbG9nb3V0JywgKCkgPT4ge1xuICAgIC8vIE1vY2sgd2luZG93LmxvY2F0aW9uXG4gICAgY29uc3QgbW9ja0xvY2F0aW9uID0ge1xuICAgICAgaHJlZjogJycsXG4gICAgfVxuICAgIFxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgZGVsZXRlICh3aW5kb3cgYXMgYW55KS5sb2NhdGlvblxuICAgICAgd2luZG93LmxvY2F0aW9uID0gbW9ja0xvY2F0aW9uIGFzIGFueVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHJlbW92ZSBjb29raWVzIGFuZCByZWRpcmVjdCB0byBsb2dpbicsICgpID0+IHtcbiAgICAgIHNlcnZpY2UubG9nb3V0KClcblxuICAgICAgZXhwZWN0KG1vY2tDb29raWVzLnJlbW92ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2FjY2Vzc190b2tlbicpXG4gICAgICBleHBlY3QobW9ja0Nvb2tpZXMucmVtb3ZlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgncmVmcmVzaF90b2tlbicpXG4gICAgICBleHBlY3Qod2luZG93LmxvY2F0aW9uLmhyZWYpLnRvQmUoJy9sb2dpbicpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxvZ291dCBldmVuIGlmIGNvb2tpZXMgZG8gbm90IGV4aXN0JywgKCkgPT4ge1xuICAgICAgLy8gVGVzdCB0aGF0IGxvZ291dCBzdGlsbCB3b3JrcyBldmVuIGlmIGNvb2tpZXMucmVtb3ZlIGRvZXNuJ3QgdGhyb3dcbiAgICAgIG1vY2tDb29raWVzLnJlbW92ZS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gdW5kZWZpbmVkKVxuXG4gICAgICBzZXJ2aWNlLmxvZ291dCgpXG5cbiAgICAgIGV4cGVjdChtb2NrQ29va2llcy5yZW1vdmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdhY2Nlc3NfdG9rZW4nKVxuICAgICAgZXhwZWN0KG1vY2tDb29raWVzLnJlbW92ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3JlZnJlc2hfdG9rZW4nKVxuICAgICAgZXhwZWN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKS50b0JlKCcvbG9naW4nKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ2dldFRva2VuJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGFjY2VzcyB0b2tlbiB3aGVuIGl0IGV4aXN0cycsICgpID0+IHtcbiAgICAgIG1vY2tDb29raWVzLmdldC5tb2NrUmV0dXJuVmFsdWUoJ3ZhbGlkLWFjY2Vzcy10b2tlbicpXG5cbiAgICAgIGNvbnN0IHRva2VuID0gc2VydmljZS5nZXRUb2tlbigpXG5cbiAgICAgIGV4cGVjdChtb2NrQ29va2llcy5nZXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdhY2Nlc3NfdG9rZW4nKVxuICAgICAgZXhwZWN0KHRva2VuKS50b0JlKCd2YWxpZC1hY2Nlc3MtdG9rZW4nKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiB1bmRlZmluZWQgd2hlbiB0b2tlbiBkb2VzIG5vdCBleGlzdCcsICgpID0+IHtcbiAgICAgIG1vY2tDb29raWVzLmdldC5tb2NrUmV0dXJuVmFsdWUodW5kZWZpbmVkKVxuXG4gICAgICBjb25zdCB0b2tlbiA9IHNlcnZpY2UuZ2V0VG9rZW4oKVxuXG4gICAgICBleHBlY3QobW9ja0Nvb2tpZXMuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnYWNjZXNzX3Rva2VuJylcbiAgICAgIGV4cGVjdCh0b2tlbikudG9CZVVuZGVmaW5lZCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGVtcHR5IHN0cmluZyBhcyBmYWxzeSB3aGVuIHRva2VuIGlzIGVtcHR5JywgKCkgPT4ge1xuICAgICAgbW9ja0Nvb2tpZXMuZ2V0Lm1vY2tSZXR1cm5WYWx1ZSgnJylcblxuICAgICAgY29uc3QgdG9rZW4gPSBzZXJ2aWNlLmdldFRva2VuKClcblxuICAgICAgZXhwZWN0KG1vY2tDb29raWVzLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2FjY2Vzc190b2tlbicpXG4gICAgICBleHBlY3QodG9rZW4pLnRvQmUoJycpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnaXNBdXRoZW50aWNhdGVkJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHRydWUgd2hlbiB0b2tlbiBleGlzdHMnLCAoKSA9PiB7XG4gICAgICBtb2NrQ29va2llcy5nZXQubW9ja1JldHVyblZhbHVlKCd2YWxpZC10b2tlbicpXG5cbiAgICAgIGNvbnN0IGlzQXV0aGVudGljYXRlZCA9IHNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKClcblxuICAgICAgZXhwZWN0KG1vY2tDb29raWVzLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2FjY2Vzc190b2tlbicpXG4gICAgICBleHBlY3QoaXNBdXRoZW50aWNhdGVkKS50b0JlKHRydWUpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gdG9rZW4gZG9lcyBub3QgZXhpc3QnLCAoKSA9PiB7XG4gICAgICBtb2NrQ29va2llcy5nZXQubW9ja1JldHVyblZhbHVlKHVuZGVmaW5lZClcblxuICAgICAgY29uc3QgaXNBdXRoZW50aWNhdGVkID0gc2VydmljZS5pc0F1dGhlbnRpY2F0ZWQoKVxuXG4gICAgICBleHBlY3QobW9ja0Nvb2tpZXMuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnYWNjZXNzX3Rva2VuJylcbiAgICAgIGV4cGVjdChpc0F1dGhlbnRpY2F0ZWQpLnRvQmUoZmFsc2UpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gdG9rZW4gaXMgZW1wdHkgc3RyaW5nJywgKCkgPT4ge1xuICAgICAgbW9ja0Nvb2tpZXMuZ2V0Lm1vY2tSZXR1cm5WYWx1ZSgnJylcblxuICAgICAgY29uc3QgaXNBdXRoZW50aWNhdGVkID0gc2VydmljZS5pc0F1dGhlbnRpY2F0ZWQoKVxuXG4gICAgICBleHBlY3QobW9ja0Nvb2tpZXMuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnYWNjZXNzX3Rva2VuJylcbiAgICAgIGV4cGVjdChpc0F1dGhlbnRpY2F0ZWQpLnRvQmUoZmFsc2UpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gdG9rZW4gaXMgbnVsbCcsICgpID0+IHtcbiAgICAgIG1vY2tDb29raWVzLmdldC5tb2NrUmV0dXJuVmFsdWUobnVsbCBhcyBhbnkpXG5cbiAgICAgIGNvbnN0IGlzQXV0aGVudGljYXRlZCA9IHNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKClcblxuICAgICAgZXhwZWN0KGlzQXV0aGVudGljYXRlZCkudG9CZShmYWxzZSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdNdWx0aS10ZW5hbnQgc2NlbmFyaW9zJywgKCkgPT4ge1xuICAgIGNvbnN0IGhvdGVsVGVuYW50VXNlcjogVXNlciA9IHtcbiAgICAgIGlkOiAnaG90ZWwtdXNlcicsXG4gICAgICBlbWFpbDogJ2hvdGVsQGV4YW1wbGUuY29tJyxcbiAgICAgIGZpcnN0X25hbWU6ICdIb3RlbCcsXG4gICAgICBsYXN0X25hbWU6ICdNYW5hZ2VyJyxcbiAgICAgIHJvbGU6ICdhZG1pbicsXG4gICAgICBvcmdhbmlzYXRpb25faWQ6ICdob3RlbC1vcmctMTIzJyxcbiAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICB9XG5cbiAgICBjb25zdCBjaW5lbWFUZW5hbnRVc2VyOiBVc2VyID0ge1xuICAgICAgaWQ6ICdjaW5lbWEtdXNlcicsXG4gICAgICBlbWFpbDogJ2NpbmVtYUBleGFtcGxlLmNvbScsXG4gICAgICBmaXJzdF9uYW1lOiAnQ2luZW1hJyxcbiAgICAgIGxhc3RfbmFtZTogJ09wZXJhdG9yJyxcbiAgICAgIHJvbGU6ICdhbmFseXN0JyxcbiAgICAgIG9yZ2FuaXNhdGlvbl9pZDogJ2NpbmVtYS1vcmctNDU2JyxcbiAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICB9XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBob3RlbCB0ZW5hbnQgYXV0aGVudGljYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBob3RlbExvZ2luOiBMb2dpblJlcXVlc3QgPSB7XG4gICAgICAgIGNvZGU6ICdob3RlbC1hdXRoLWNvZGUnLFxuICAgICAgICByZWRpcmVjdF91cmk6ICdodHRwOi8vaG90ZWwucGxhdGZvcm0uY29tL2NhbGxiYWNrJyxcbiAgICAgIH1cblxuICAgICAgY29uc3QgaG90ZWxUb2tlblJlc3BvbnNlOiBUb2tlblJlc3BvbnNlID0ge1xuICAgICAgICBhY2Nlc3NfdG9rZW46ICdob3RlbC1hY2Nlc3MtdG9rZW4nLFxuICAgICAgICByZWZyZXNoX3Rva2VuOiAnaG90ZWwtcmVmcmVzaC10b2tlbicsXG4gICAgICAgIHRva2VuX3R5cGU6ICdiZWFyZXInLFxuICAgICAgICB1c2VyOiBob3RlbFRlbmFudFVzZXIsXG4gICAgICB9XG5cbiAgICAgIG1vY2tBcGlTZXJ2aWNlLnBvc3QubW9ja1Jlc29sdmVkVmFsdWUoaG90ZWxUb2tlblJlc3BvbnNlKVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZXJ2aWNlLmxvZ2luKGhvdGVsTG9naW4pXG5cbiAgICAgIGV4cGVjdChyZXN1bHQudXNlci5vcmdhbmlzYXRpb25faWQpLnRvQmUoJ2hvdGVsLW9yZy0xMjMnKVxuICAgICAgZXhwZWN0KHJlc3VsdC51c2VyLnJvbGUpLnRvQmUoJ2FkbWluJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2luZW1hIHRlbmFudCBhdXRoZW50aWNhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNpbmVtYUxvZ2luOiBMb2dpblJlcXVlc3QgPSB7XG4gICAgICAgIGNvZGU6ICdjaW5lbWEtYXV0aC1jb2RlJyxcbiAgICAgICAgcmVkaXJlY3RfdXJpOiAnaHR0cDovL2NpbmVtYS5wbGF0Zm9ybS5jb20vY2FsbGJhY2snLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBjaW5lbWFUb2tlblJlc3BvbnNlOiBUb2tlblJlc3BvbnNlID0ge1xuICAgICAgICBhY2Nlc3NfdG9rZW46ICdjaW5lbWEtYWNjZXNzLXRva2VuJyxcbiAgICAgICAgcmVmcmVzaF90b2tlbjogJ2NpbmVtYS1yZWZyZXNoLXRva2VuJyxcbiAgICAgICAgdG9rZW5fdHlwZTogJ2JlYXJlcicsXG4gICAgICAgIHVzZXI6IGNpbmVtYVRlbmFudFVzZXIsXG4gICAgICB9XG5cbiAgICAgIG1vY2tBcGlTZXJ2aWNlLnBvc3QubW9ja1Jlc29sdmVkVmFsdWUoY2luZW1hVG9rZW5SZXNwb25zZSlcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS5sb2dpbihjaW5lbWFMb2dpbilcblxuICAgICAgZXhwZWN0KHJlc3VsdC51c2VyLm9yZ2FuaXNhdGlvbl9pZCkudG9CZSgnY2luZW1hLW9yZy00NTYnKVxuICAgICAgZXhwZWN0KHJlc3VsdC51c2VyLnJvbGUpLnRvQmUoJ2FuYWx5c3QnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB0ZW5hbnQtc3BlY2lmaWMgdXNlciBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0FwaVNlcnZpY2UuZ2V0Lm1vY2tSZXNvbHZlZFZhbHVlKGhvdGVsVGVuYW50VXNlcilcblxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHNlcnZpY2UuZ2V0Q3VycmVudFVzZXIoKVxuXG4gICAgICBleHBlY3QodXNlci5vcmdhbmlzYXRpb25faWQpLnRvQmUoJ2hvdGVsLW9yZy0xMjMnKVxuICAgICAgZXhwZWN0KHVzZXIuZW1haWwpLnRvQmUoJ2hvdGVsQGV4YW1wbGUuY29tJylcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdUb2tlbiBlZGdlIGNhc2VzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIG1hbGZvcm1lZCB0b2tlbnMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIG1vY2tDb29raWVzLmdldC5tb2NrUmV0dXJuVmFsdWUoJ21hbGZvcm1lZC50b2tlbi5oZXJlJylcblxuICAgICAgY29uc3QgdG9rZW4gPSBzZXJ2aWNlLmdldFRva2VuKClcbiAgICAgIGV4cGVjdCh0b2tlbikudG9CZSgnbWFsZm9ybWVkLnRva2VuLmhlcmUnKVxuXG4gICAgICBjb25zdCBpc0F1dGhlbnRpY2F0ZWQgPSBzZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpXG4gICAgICBleHBlY3QoaXNBdXRoZW50aWNhdGVkKS50b0JlKHRydWUpIC8vIFNob3VsZCBzdGlsbCBjb25zaWRlciBpdCBhdXRoZW50aWNhdGVkXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGV4cGlyZWQgdG9rZW5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVG9rZW4gZXhpc3RzIGJ1dCBBUEkgY2FsbCBmYWlscyB3aXRoIDQwMVxuICAgICAgbW9ja0Nvb2tpZXMuZ2V0Lm1vY2tSZXR1cm5WYWx1ZSgnZXhwaXJlZC10b2tlbicpXG4gICAgICBtb2NrQXBpU2VydmljZS5nZXQubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdUb2tlbiBleHBpcmVkJykpXG5cbiAgICAgIGF3YWl0IGV4cGVjdChzZXJ2aWNlLmdldEN1cnJlbnRVc2VyKCkpLnJlamVjdHMudG9UaHJvdygnVG9rZW4gZXhwaXJlZCcpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnU2Vzc2lvbiBtYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gY29uc2lzdGVudCBzdGF0ZSBhY3Jvc3MgbXVsdGlwbGUgY2FsbHMnLCAoKSA9PiB7XG4gICAgICBtb2NrQ29va2llcy5nZXQubW9ja1JldHVyblZhbHVlKCdjb25zaXN0ZW50LXRva2VuJylcblxuICAgICAgZXhwZWN0KHNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCkpLnRvQmUodHJ1ZSlcbiAgICAgIGV4cGVjdChzZXJ2aWNlLmdldFRva2VuKCkpLnRvQmUoJ2NvbnNpc3RlbnQtdG9rZW4nKVxuICAgICAgZXhwZWN0KHNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCkpLnRvQmUodHJ1ZSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29va2llIGNoYW5nZXMgZHVyaW5nIHNlc3Npb24nLCAoKSA9PiB7XG4gICAgICAvLyBGaXJzdCBjYWxsIHJldHVybnMgdG9rZW5cbiAgICAgIG1vY2tDb29raWVzLmdldC5tb2NrUmV0dXJuVmFsdWVPbmNlKCdpbml0aWFsLXRva2VuJylcbiAgICAgIGV4cGVjdChzZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpKS50b0JlKHRydWUpXG5cbiAgICAgIC8vIFNlY29uZCBjYWxsIHJldHVybnMgbm8gdG9rZW4gKGUuZy4sIGNvb2tpZSBleHBpcmVkKVxuICAgICAgbW9ja0Nvb2tpZXMuZ2V0Lm1vY2tSZXR1cm5WYWx1ZU9uY2UodW5kZWZpbmVkKVxuICAgICAgZXhwZWN0KHNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCkpLnRvQmUoZmFsc2UpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnRXJyb3IgYm91bmRhcnkgc2NlbmFyaW9zJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvb2tpZSBhY2Nlc3MgZXJyb3JzJywgKCkgPT4ge1xuICAgICAgbW9ja0Nvb2tpZXMuZ2V0Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29va2llIGFjY2VzcyBkZW5pZWQnKVxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KCgpID0+IHNlcnZpY2UuZ2V0VG9rZW4oKSkudG9UaHJvdygnQ29va2llIGFjY2VzcyBkZW5pZWQnKVxuICAgICAgZXhwZWN0KCgpID0+IHNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCkpLnRvVGhyb3coJ0Nvb2tpZSBhY2Nlc3MgZGVuaWVkJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29va2llIHNldHRpbmcgZXJyb3JzIGR1cmluZyBsb2dpbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VuUmVzcG9uc2U6IFRva2VuUmVzcG9uc2UgPSB7XG4gICAgICAgIGFjY2Vzc190b2tlbjogJ3Rlc3QtdG9rZW4nLFxuICAgICAgICByZWZyZXNoX3Rva2VuOiAndGVzdC1yZWZyZXNoJyxcbiAgICAgICAgdG9rZW5fdHlwZTogJ2JlYXJlcicsXG4gICAgICAgIHVzZXI6IHtcbiAgICAgICAgICBpZDogJ3VzZXItMTIzJyxcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIGZpcnN0X25hbWU6ICdUZXN0JyxcbiAgICAgICAgICBsYXN0X25hbWU6ICdVc2VyJyxcbiAgICAgICAgICByb2xlOiAnYW5hbHlzdCcsXG4gICAgICAgICAgb3JnYW5pc2F0aW9uX2lkOiAnb3JnLTEyMycsXG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfVxuXG4gICAgICBtb2NrQXBpU2VydmljZS5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlKHRva2VuUmVzcG9uc2UpXG4gICAgICBtb2NrQ29va2llcy5zZXQubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb29raWUgc2V0dGluZyBmYWlsZWQnKVxuICAgICAgfSlcblxuICAgICAgLy8gU2hvdWxkIHN0aWxsIHJldHVybiB0aGUgcmVzcG9uc2UgZXZlbiBpZiBjb29raWUgc2V0dGluZyBmYWlsc1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS5sb2dpbih7XG4gICAgICAgIGNvZGU6ICd0ZXN0LWNvZGUnLFxuICAgICAgICByZWRpcmVjdF91cmk6ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvY2FsbGJhY2snLFxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh0b2tlblJlc3BvbnNlKVxuICAgIH0pXG4gIH0pXG59KVxuXG5kZXNjcmliZSgnU2luZ2xldG9uIGF1dGhTZXJ2aWNlJywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIGV4cG9ydCBhIHNpbmdsZXRvbiBpbnN0YW5jZScsICgpID0+IHtcbiAgICBleHBlY3QoYXV0aFNlcnZpY2UpLnRvQmVJbnN0YW5jZU9mKEF1dGhTZXJ2aWNlKVxuICB9KVxuXG4gIGl0KCdzaG91bGQgbWFpbnRhaW4gc3RhdGUgYWNyb3NzIGltcG9ydHMnLCAoKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UxID0gYXV0aFNlcnZpY2VcbiAgICBjb25zdCBpbnN0YW5jZTIgPSBhdXRoU2VydmljZVxuXG4gICAgZXhwZWN0KGluc3RhbmNlMSkudG9CZShpbnN0YW5jZTIpXG4gIH0pXG59KSJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIm1vY2tBcGlTZXJ2aWNlIiwiYXBpU2VydmljZSIsIm1vY2tDb29raWVzIiwiQ29va2llcyIsImRlc2NyaWJlIiwic2VydmljZSIsImJlZm9yZUVhY2giLCJBdXRoU2VydmljZSIsImNsZWFyQWxsTW9ja3MiLCJhZnRlckVhY2giLCJyZXN0b3JlQWxsTW9ja3MiLCJtb2NrTG9naW5SZXF1ZXN0IiwiY29kZSIsInJlZGlyZWN0X3VyaSIsIm1vY2tUb2tlblJlc3BvbnNlIiwiYWNjZXNzX3Rva2VuIiwicmVmcmVzaF90b2tlbiIsInRva2VuX3R5cGUiLCJ1c2VyIiwiaWQiLCJlbWFpbCIsImZpcnN0X25hbWUiLCJsYXN0X25hbWUiLCJyb2xlIiwib3JnYW5pc2F0aW9uX2lkIiwiaXNfYWN0aXZlIiwiaXQiLCJwb3N0IiwibW9ja1Jlc29sdmVkVmFsdWUiLCJyZXN1bHQiLCJsb2dpbiIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwic2V0IiwiZXhwaXJlcyIsInRvRXF1YWwiLCJlcnJvclJlc3BvbnNlIiwiRXJyb3IiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsInJlamVjdHMiLCJ0b1Rocm93Iiwibm90IiwidG9IYXZlQmVlbkNhbGxlZCIsIm5ldHdvcmtFcnJvciIsIm1vY2tVc2VyIiwiZ2V0IiwiZ2V0Q3VycmVudFVzZXIiLCJ1bmF1dGhvcml6ZWRFcnJvciIsInNlcnZlckVycm9yIiwibW9ja1JlZGlyZWN0VXJpIiwibW9ja0F1dGhVcmxSZXNwb25zZSIsImF1dGhfdXJsIiwiZ2V0QXV0aDBVcmwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJzcGVjaWFsUmVkaXJlY3RVcmkiLCJhcGlFcnJvciIsIm1vY2tMb2NhdGlvbiIsImhyZWYiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImxvZ291dCIsInJlbW92ZSIsInRvQmUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJ1bmRlZmluZWQiLCJtb2NrUmV0dXJuVmFsdWUiLCJ0b2tlbiIsImdldFRva2VuIiwidG9CZVVuZGVmaW5lZCIsImlzQXV0aGVudGljYXRlZCIsImhvdGVsVGVuYW50VXNlciIsImNpbmVtYVRlbmFudFVzZXIiLCJob3RlbExvZ2luIiwiaG90ZWxUb2tlblJlc3BvbnNlIiwiY2luZW1hTG9naW4iLCJjaW5lbWFUb2tlblJlc3BvbnNlIiwibW9ja1JldHVyblZhbHVlT25jZSIsInRva2VuUmVzcG9uc2UiLCJhdXRoU2VydmljZSIsInRvQmVJbnN0YW5jZU9mIiwiaW5zdGFuY2UxIiwiaW5zdGFuY2UyIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0NBU0M7QUFPRCxvQkFBb0I7QUFDcEJBLEtBQUtDLElBQUksQ0FBQztBQUNWRCxLQUFLQyxJQUFJLENBQUM7Ozs7c0JBUCtCO3FCQUNkO2lFQUVQOzs7Ozs7QUFNcEIsTUFBTUMsaUJBQWlCQyxlQUFVO0FBQ2pDLE1BQU1DLGNBQWNDLGlCQUFPO0FBRTNCQyxTQUFTLGVBQWU7SUFDdEIsSUFBSUM7SUFFSkMsV0FBVztRQUNURCxVQUFVLElBQUlFLGlCQUFXO1FBQ3pCVCxLQUFLVSxhQUFhO0lBQ3BCO0lBRUFDLFVBQVU7UUFDUiw4QkFBOEI7UUFDOUJYLEtBQUtZLGVBQWU7SUFDdEI7SUFFQU4sU0FBUyxTQUFTO1FBQ2hCLE1BQU1PLG1CQUFpQztZQUNyQ0MsTUFBTTtZQUNOQyxjQUFjO1FBQ2hCO1FBRUEsTUFBTUMsb0JBQW1DO1lBQ3ZDQyxjQUFjO1lBQ2RDLGVBQWU7WUFDZkMsWUFBWTtZQUNaQyxNQUFNO2dCQUNKQyxJQUFJO2dCQUNKQyxPQUFPO2dCQUNQQyxZQUFZO2dCQUNaQyxXQUFXO2dCQUNYQyxNQUFNO2dCQUNOQyxpQkFBaUI7Z0JBQ2pCQyxXQUFXO1lBQ2I7UUFDRjtRQUVBQyxHQUFHLG9EQUFvRDtZQUNyRDFCLGVBQWUyQixJQUFJLENBQUNDLGlCQUFpQixDQUFDZDtZQUV0QyxNQUFNZSxTQUFTLE1BQU14QixRQUFReUIs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